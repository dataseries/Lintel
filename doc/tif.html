<html>
<head>
   <title> TIF - The Tcl interface functions</title>
</head>
<body bgcolor="#FFFFFF">

<center>
<h1>TIF - The Tcl interface functions</h1>
</center>

<center>
<h1>Alistair Veitch</h1>
</center>

<h2>Introduction</h2>

Many SSP programs use a combination of Tcl and C++. This
document describes the means through which the code which glues these two
languages together is produced. Essentially, the code allows you to manipulate
C++ objects from within your Tcl code, and call methods and functions utilizing
these objects.

<h2>A simple example</h2>

Before diving into the details of the Tcl interface functions
(TIF), lets look at a simple example. This will serve to give an overview
of how everything works. Lets consider a simple class, that you wish to
make accessible from Tcl scripts. The header file (simple.H) for this class
is shown below. Note that in all code examples, much detail (e.g. <tt>#include</tt>
statements), has been ommitted for clarity).

<pre>
    class simple {
    private:
        int val;
    public:
        void set(int v) { val = v; };
        int get() { return val; };
    };
</pre>

Further, lets assume that you want to make it possible
to call the `set' method from Tcl. To accomplish this, you must take four
steps:

<ul>
<li> Add a TIFclass directive to simple.H
<li> Add a TIFmethod directive to simple.H
<li> Change simple to inherit from the TclInterface class
<li> Run buildTcl to generate interface code.
</ul>

Lets examine the changes to simple.H. The final file
will look something like this:

<pre>
    class simple : virtual public TclInterface{
    private:
	int val;
    public:
	//TIFmethod
	void set(int v) { val = v; };
	int get() { return val; };
    };

    //TIFclass simple

</pre>

<p>
The TIFclass directive essentially says "here is a class
I want to be able to use from Tcl". The TIFmethod directive says "the next
line defines a method I want to be able to use from my Tcl code". The 
inheritance from TclInterface is necessary so that internal type-checking can 
be done by the TIF internals.

<p>
The final step is to run `buildTcl'. This command reads
a list of .H files (after the -t argument) and uses the information gleaned
from them to generate a source file (after the -o argument) that contains
all the code necessary to make the Tcl interface work. So, in our example
above, we might use the command:

<pre>
    buildTcl -t simple.H -o simpleTcl.C
</pre>

<p>
You would then compile simpleTcl.C into your final program,
and hey presto! it works. That is, you can evaluate a tcl script with 
statements like:

<pre>
    # create a new simple object
    set s [simple]
    # set val to 5
    $simple.set 5
</pre>


<h2>Header file components</h2>

In general, all the interesting information about a class
- it's name, methods and their types etc. -can be found in header files.
When using TIF, this is the information that matters for describing and
building code that will interface with the class, so this is typically
where almost all the TIF functionality must be added. The next sections
discuss each of the changes or directives that must be added to a typical
header file.

<h3>TclInterface inheritance</h3>

All classes that want to use the TIF functionality must
inherit from the TclInterface class. The reasons for doing this is to 
facilitate type checking, but are sufficiently arcane that we won't go into 
them here - come talk to me if you really want to know. To ensure that only 
one copy of the TclInterface base class is present for each derived class, 
virtual inheritance should be used. Note that if you're already inheriting
from a class that inherits from TclInterface, you don't have to do it again!
Finally, it's worth noting that you should have a 
`<tt>#include&nbsp;&lt;TclInterface.H&gt;</tt>', to pick up the appropriate 
definitions.

<h3>TIFclass</h3>

The TIFclass directive should be used once for every
class that you wish to be accessible in your Tcl scripts. It essentially
serves as notification to the buildTcl program that it must construct code
that allows Tcl programmers to create and use objects of this class. TIFclass
directives must not be inside of class (or any other) definitions. Typically,
you will put TIFclass directives at the end of the file in which your class
is defined. This is useful, as using buildTcl will result in a small amount
of code being inserted into your .H file, and having it at the end reduces
any possible confusion.

<p>
It should be noted that the code is well commented as being automatically 
generated, and that
buildTcl will not insert multiple copies of this code. The function headers
defined in the code are there for the convenience of those who wish to
bypass some of the default TIF code generation. Full details can be found
in the section on <a href="#CustomMethod">custom methods and functions</a>.

<p>
The TIFclass directive has the following syntax:

<pre>
    TIFclass [ abstract ] class-name
</pre>

where <em>class-name</em> is the name of the class which is being
declared. If the class in question is an abstract base class (contains
pure virtual methods), you must add the abstract keyword - if you don't,
you'll get errors when you try and compile your code, as the TIF system
will try to make a constructor for the class.

<p>
TIFclass, and all other TIF directives, must be preceded
with //, to hide them from the C++ compiler. There can be no spaces between
the // and TIF directive.

<h3>TIFmethod</h3>

The TIFmethod directive should be used once for every
method that you wish to have available to you from Tcl. The syntax is 
straightforward:

<pre>
    TIFmethod [ custom ] [ usage ]
</pre>

TIFmethod directives <b>must</b> be inserted immediately before
the lines containing the method definition. After the directive (but on
the same line) there can be the optional "custom" keyword. The usage of
this keyword is explained in the <a href="#CustomMethod">custom methods and 
functions</a> section. Anything following this keyword - or the directive
itself if it is not present - is used as a usage message, and will be printed
as part of the error message from TIF if the user wrongly executes (e.g.
too few or many arguments, wrong type of arguments) the method. If no usage
is supplied, the system will create one from the method signature.

<p>
TIFmethod should be used for constructors as well as
regular methods. The usage is exactly the same. The only difference in
behavior is that instead of a new Tcl procedure for the method being created,
it becomes possible to pass arguments to the constructor that is built
as a result of the classes TIFclass directive.

<h3>TIFfunction</h3>

TIFfunction serves the same purpose as TIFmethod, expect
for functions instead of methods. The usage is identical as well:

<pre>
    TIFfunction [ custom ] [ usage ]
</pre>

and must appear immediately before the line containing
the function signature.

<h2>Available types</h2>

The base types currently usable by TIF methods and functions
are as follows:

<ul>
<li> void (return type only)
<li> int
<li> unsigned
<li> long
<li> u_long
<li> byte_t (from Lintel)
<li> LintelTime (from Lintel)
<li> double
<li> bool
<li> char *
<li> string
<li> enum's
<li> class *
<li> class &amp;
<li> STL lists of any of the above, except void and class references
</ul>

<p>
The majority of these types should be straightforward
to all C++ programmers. enum's must be named (i.e. they must be declared
as `enum&nbsp;<em>name</em>&nbsp;{...}'. `char&nbsp;*' types are used to pass 
(or return) C-style strings to/from Tcl. 
`class&nbsp;*' and `class&nbsp;&amp;' types are used to indicate that the 
argument is a class itself. The class used must be one that is known to the TIF
system (i.e. one for which a TIFclass directive has been specified). The
other important type that must be handled by any Tcl system is lists. TIF
will automatically convert between Tcl and STL lists, which ensures maximum
flexibility in usage.

<h2>Using buildTcl</h2>

buildTcl is an awk script that reads all the files containing
TIF directives, and generates a source file that can be compiled and linked
into the final application. buildTcl is invoked as follows:

<pre>
    buildTcl [-- -l header-files] -t header-files -o source-file
</pre>

where <em>header-files</em> are an arbitrary number of header
(.H) files, and <em>source-file</em> is the name of a source file that will
be generated. The '--' argument is neccessary to prevent any hyphenated 
arguments from being interpreted as awk arguments (as opposed to buildTcl
arguments) by HP-UX awk. gawk and mawk don't have this restriction.
The header-files are (potentially) split into two groups. All files after
the -t option are used in generating the final code. Files after the -l
option are typically library files, and are processed only to get class
and method information for possible use in classes or methods in the primary
set of header files. This facility is needed as code for library files
has presumably been generated, and included in the library, and should
not be generated again, but the classes defined there may be needed as
arguments to methods in the application code.

<p>
buildTcl will overwrite the original source file. The
first time it is run against a given header file, it will also insert a
small amount of code after any TIFclass directives. It will not change
header files in future, unless the directives in that file change. Whenever
a file is changed, the original version is backed up in a file of the same
name, with the addition of a `~' extension. The very first time buildTcl
is used, it is probably worth quickly checking each of the original .H
files, to ensure that buildTcl has "done the right thing".

<h2>Creating a Tcl interpreter and initialization</h2>

Before evaluating Tcl files or expressions, a Tcl interpreter
must be created. In the TIF world, this is done by calling the function,
TIFinit(), which initializes the TIF runtime and returns a tcl interpreter
that contains all the procedures for accessing any defined Tcl objects.
For applications which wish to use Tcl_Main() (which will also create a
Tcl interpreter) TIFinit may also be called with an argument of a previously
created interpreter. In this case, only the TIF runtime is initialized.

<h2>A more complex example</h2>

You have a library (like Lintel) that has some code in
it that defines a virtual class that you wish to use in your program. The
library class is defined in libclass.H, which looks like this:

<pre>
    class libclass : virtual public tclInterface {
    public:
	//TIFmethod
	virtual void printSomething() =0;
    };

    //TIFclass abstract libclass
</pre>

<p>
You implement a series of other classes, some of which
may use this class. The code for these classes is shown below. Note that
these classes are all pretty silly, they are just designed to illustrate
the usage of most of the TIF features.

<p>
In `myint.H':

<pre>
    class myint : public libclass {
    private:
	int val;
    public:
	//TIFmethod myint number
	myint(int v) : val(v) {};
	//TIFmethod set number
	void set(int v) { val = v; };
	//TIFmethod
	int get() { return val; };
	virtual void printSomething() {
	    cout &lt;&lt; "myint = " &lt;&lt; val &lt;&lt; endl;
	};
    };

    //TIFclass myint
</pre>

<p>
Note that printSomething() does not need to have an associated
TIFmethod directive. This is because buildTcl will pick this up from libclass.
Having a TIFmethod directive for this method in myint.H would however do
no harm.

<p>
In `doubleString.H':

<pre>
    class doubleString : virtual public tclInterface {
    private:
	double d;
	string s;
    public:
	doubleString() : d(0.0), s("blank ") {};
	//TIFmethod set number string
	void set(double din, string &amp;sin) { d = din; s = sin; };
	//TIFmethod setFromInt myint
	void setFromInt(myint &amp;mi) { d = mi.get(); };
	//TIFmethod
	double getDouble() { return d; };
	//TIFmethod
	string getString() { return s; };
    };

    //TIFclass doubleString
</pre>

<p>
Next, lets say we have two functions that manipulate these
new classes in various ways:

<pre>
    myint &amp;doSomething(bool doIt, list&lt;doubleString*&gt; dsList) {
	for (list&lt;doubleString *&gt;::iterator i = dsList.begin(); i != dsList.end(); i++) {
	    if (doIt) {
		cout &lt;&lt; (*i)->getString()
		     &lt;&lt; (*i)->getDouble() &lt;&lt; endl;
	    }
	}
	myint *ret = new myint(dsList.size());
    	return *ret;
    }

    list &lt;int&gt; doSomething2(int len) {
	list&lt;int&gt; ret;
	for (unsigned i = 0; i &lt; len; i++) {
	    ret.push_back(i);
	}
	return ret;
    }
</pre>

<p>
of course, the header file (doIt.H) for these functions
would need a TIFfunction directive immediately before the definition line
for doSomething().

<p>
Now, before we can compile and link all this stuff together,
we need to run buildTcl:

<pre>
    buildTcl -- -l libclass.H -t myint.H doubleString.H doIt.H -o myTcl.C
</pre>

<p>
and make sure we compile and link myTcl.C with the rest
of the application, as well as the library containing libclass.

<p>
Finally, we can evaluate Tcl scripts in our new program.
A sample script is shown below:

<pre>
    set m1 [myint 5];
    $m1.printSomething;
    $m1.set 3;
    set m2 [myint 7];
    puts [expr [$m2.get] - [$m1.get]];
    set ds1 [doubleString];
    set ds2 [doubleString];
    $ds2.set 1.23 "doubleString here! ";
    set m3 [doSomething true "$ds1 $ds2"];
    puts "list length was [$m3.get];
    set l1 [doSomething2 4];
    puts "generated list : $l1";
</pre>

<p>
This script generates the following output:

<pre>
    myint = 5
    4
    blank 0
    doubleString here! 1.23
    list length was 2
    generated list : 0 1 2 3
</pre>

<a name="CustomMethod">
<h2>Custom methods and functions</h2>

There may be circumstances in which the automatic generation
of argument processing code is insufficient. These might include functions
in which the operation done depends on the arguments, or methods that must
be overloaded. In this case, you have to write your own C++ code to accomplish
this functionality. Fortunately, this is relatively easy, and TIF generates
several utility functions that can be used. As a simple example, we'll
revisit the doubleString class, and pretend that we want to add a constructor
(so we now have two):

<pre>
    doubleString() : d(0.0), s("blank ") {};
    doubleString(myint &amp;mi, string s_in) : d(mi.get()), s(s_in) {};
</pre>

<p>
The first step is to ensure that a command implementing
these two constructors is written. One possible implementation is:

<pre>
    int doubleStringCmd(ClientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
	doubleString *dsp;
	switch (objc) {
	case 1:
	    dsp = new doubleString;
	    break;
	case 3:
	    myint *mip;
	    int error = Tcl_GetmyintFromObj(interp, objv[1], &amp;mip);
	    if (error != TCL_OK) {
		Tcl_AppendResult(interp, "bad first argument", NULL);
		return error;
	    }
	    dsp = new doubleString(*mip, Tcl_GetStringFromObj(objv[2], NULL));
	    break;
	default:
	    Tcl_AppendResult(interp, "doubleString: wrong number of args", NULL);

	    return TCL_ERROR;
	}

	Tcl_Declare_doubleString(interp, dsp);
	return TCL_OK;
    }
</pre>

<p>
Quickly summarizing this function, all Tcl functions have
the same basic signature, that of an interpreter, count of objects passed,
and an array of objects. The first (0'th) object is always the string with
the proc name. By switching on the argument count, the type of constructor
to use can be determined. In the no argument case, this is a trivial call.
In the next case, a myint object must be obtained from the first argument.
For each class, TIF will provide a function that takes a Tcl object pointer
and pointer to pointer to class, and returns an indication of whether the 
object can be converted to that
class. (the 
syntax is chosen to conform with all other standard Tcl_GetXFromObj calls.
Note that Tcl_GetStringFromObj() is slightly different, as all Tcl objects
are also strings, so this call always succeeds, and returns it's argument
directly. For more information on this and all other Tcl procedures, consult
the man pages or "Practical Programming in Tcl and Tk" by Brent Welch.)
If successful, TCL_OK is returned, and the pointer to the object
will be instantiated. If unsuccessful, the interpreters result is set to
an appropriate message, and the error indication is returned. The new doubleString
object can now be created from the myint object and the second argument
string. The final step calls the function Tcl_Declare_doubleString(). This
is required for all functions that return objects, and ensures that all
the appropriate methods for that object are registered. One function of
this type will be created for each class.

<p>
The only other step that is normally required is to ensure
that this command is registered when the Tcl interpreter is created. This
can be accomplished by the following line of code:

<pre>
    TclInterface TIF_doubleString("doubleString", doubleStringCmd);
</pre>

<p>
i.e. declaring a TclInterface object, where the first argument
is the name of the command, and the second is the function implementing
that command.

<p>
Since we are defining a constructor, rather than a method,
there is one other step that must be taken, which is to ensure that the
TIFclass directive does not result in a default constructor being made.
This can be accomplished by adding the abstract keyword after the directive (I
know, this could be more elegant, but that would also require more work, 
by both me and the code writer).

<p>
Adding a custom constructor is actually slightly more complex
than adding a custom method or function. Let's say we want to add a custom
method, "foo", to the doubleString class. This is done in three steps.

<p>Firstly, in the TIFmethod line, use the custom keyword:

<pre>
    //TIFmethod custom
    void foo(...); // arguments removed for exposition purposes
</pre>

<p>
Secondly, write the function that implements this command.
For methods, the name of this function must be the concatenation of the
object type, the method name and "Cmd". For custom functions, it is just
the function name and "Cmd". In this case, the method name would thus be
"doubleStringfooCmd". The prototype is exactly the same as the custom constructor
above. For methods, a pointer to the class itself can be got from the first
(ClientData) argument. The code for the function implementing the foo command
would thus be something like:

<pre>
    int doubleStringfooCmd(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
	doubleString *dpPtr = (doubleString *) clientData;
	// do some argument processing
	dpPtr->foo(...); // call foo with appropriate args
    }
</pre>

<p>
Presumably this function will be implemeted in doubleString.C.
The final step is to put a declaration of the function in the header file
(doubleString.H in this case), so it can be found by the code buildTcl
generates. The command definition is done automatically (i.e. the TclInterface
declaration as used by the custom doubleString constructor is not needed).

<h2>Enums</h2>
There is currently support for passing enums by name. However, it hasn't
been documented yet.

<h2>Common errors</h2>

This section will become a list of common operating errors,
and their fixes. I'll add them as they become apparent. For now, anything
that seems strange will probably be an error in the buildTcl script, not
with your code, so please let me know!

<ul>
<li>Not using virtual inheritance for the TclInterface inheritance. Symptoms
are...
</ul>

<h3>Overloaded methods/functions</h3>

There is currently no support for overloaded methods
or functions. If you try this, buildTcl will only "see" the last one declared.
Simple overloading will not be too difficult to add, and I will probably
do so some weekend. In the mean time, you'll just have to write your own,
<em>a la</em> the doubleString constructor example.

</body>
</html>
