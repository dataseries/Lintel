#!@PERL_PATH@ -w
# -*- Perl -*-
#
#  (c) Copyright 2004-2006, Hewlett-Packard Development Company, LP
#
#  See the file named COPYING for license details
#
# Script for running batch processing type operations, extended
# by a module that controls how the jobs are selected and executed
use strict;
use Carp 'confess';
use Data::ShowTable;
use DBI;
use English;
use Fcntl qw/F_GETFL F_SETFL O_NONBLOCK/;
use File::Basename;
use FileHandle;
use Getopt::Long;
use IO::Select;
use Pod::Usage;
use POSIX ":sys_wait_h";
use Safe;
use Term::ReadLine;
use Time::HiRes 'time';

@PERL5_MODULES_INC_UNSHIFT@;
use Plot::Mercury;
# TODO: make it possible to run mercury without IO::Pty -- that module
# isn't part of a standard RHEL4 install.

# TODO: now that we can use a pty to talk to gnuplot, we need to
# scatter calls to readinput throughout the code, for example without
# the one in pngplot before the "Wait for stability on gnuplot writing
# the ps file" comment, we don't get a postscript file generated.

# TODO: switch from use of open(GLOBAL, "...") to new FileHandle
# this caused nested includes to not work.
use IO::Pty;
my $using_pty = 1;


eval "use Statistics::OLS;";
my $missing_statistics_ols = $@;

$|=1;
my $gnuplot_fifo;
my $term;

if (-t STDIN) {
    $term = new Term::ReadLine 'Experiment Plotter';
    $term->ornaments("0");
}
my $history_file = ".plot.history";
my $user;
my $password;
my $db;
my $print_manpage;
my $debug = 0;
my $batch = 0;
my $success = GetOptions("dsn=s" => \$Plot::Mercury::Default_DSN,
			 "db=s" => \$db,
			 "user=s" => \$user,
			 "password=s" => \$password,
			 "history=s" => \$history_file,
			 "debug!" => \$debug,
			 "man!" => \$print_manpage,
			 "batch!" => \$batch);
pod2usage(-verbose => 2, -exitval => 0) if $print_manpage;
eval "package MercuryEval; use Plot::Mercury; "; die "$@" if $@;

die "Usage: $0 
    [--db=<database-key>] # as specified in the file ~/.mercury-dbs or /etc/MercuryDBs
    # with the format of each line either being a '#' comment or
    # <key> <DSN> [user] [password]
    [--dsn=<dbd spec, currently $Plot::Mercury::Default_DSN>]
    # dsn can be stored in the environment variable MERCURY_DSN
    # or in the file /etc/MercuryDSN
    [--user=<user>] [--password=<password>]
    [--history=<history-filename, default $history_file>]
    [--help] [--man] [--debug] [--batch] [input-file ...] [< input]\n"
    unless $success;

my $gnuplot_terminal_type = $batch ? "unknown" : "x11";

if (defined $db) {
    ($Plot::Mercury::Default_DSN,$user,$password) 
	= Plot::Mercury::getDSNbykey($db,"$ENV{HOME}/.mercury-dbs");
    ($Plot::Mercury::Default_DSN,$user,$password) 
	= Plot::Mercury::getDSNbykey($db,"/etc/MercuryDBs")
	    unless defined $Plot::Mercury::Default_DSN;
    die "Unable to find database specification for '$db' in either $ENV{HOME}/.mercury-dbs or /etc/MercuryDBs"
	unless defined $Plot::Mercury::Default_DSN;
}

if (defined $user) {
    Plot::Mercury->connectToDB($Plot::Mercury::Default_DSN,$user,$password);
}

my $plotfiles = 0;
my $command_error = 0; # Set this if there is an error evaluating a command
		       # so that we can stop a 'history do' or other 
		       # multi-part command; ** not completed as of 3Jan01 ** 

my @history;
if (-f $history_file) {
    my $fh = new FileHandle $history_file
	|| die "Unable to open $history_file for read: $!\n";
    @history = <$fh>;
    foreach $_ (@history) {
	chomp;
	$term->addhistory($_) if defined $term;
    }
    print "Loaded history from ${history_file}.\n";
    close($fh);
}

sub saveexit;
sub help;
sub pause;
sub sqlselect;
sub htmlselect;
sub sqlplot;
sub barplot;
sub sqlcmd;
sub history;
sub docmd;
sub unplot;
sub listplot;
sub fnplot;
sub replot;
sub gnuplot;
sub pngplot;
sub psplot;
sub plotwith;
sub axplusb;
sub default;
sub fncmds;
sub import_data;

$Global::source_dir = dirname($0);
my $define_mode = 0;
my @define;
my $markerre;
my $prompt = ">> ";

$Global::continuation_cmd = '';
map { die "command line input file $_ is not readable" unless -f $_ && -r $_; } @ARGV;
map { print "Reading from $_\n" if $debug;
      history("run $_"); exit(1) if $command_error; } @ARGV;

unless (defined $term) {
    while(<STDIN>) {
	docmd($_);
	exit(1) if $command_error;
    }
    exit(0);
}

while (defined ($_ = $term->readline("$prompt"))) {
    $command_error = 0;
    eval { &docmd($_) };
    print "Error executing command: $@\n" if $@;
}
&saveexit;

=pod

=head1 NAME

mercury-plot - plot data out of an SQL database

=head1 SYNOPSIS

% mercury-plot [--man] [--dsn=DBI dsn spec] [--db=<database-key>]
               [--user=<user>] [--password=<password>]
               [--history=<history filename>]

=head1 OVERVIEW

    select <sql select arguments>
    plot <sql select arguments>, with columns named x,{y,y2}, [yerr,(ylo,yhi)]
    sql <sql statement>
    listplot
    unplot [<plotnum>]
    fnplot <function>
    barplot <sql select arguments>, with columns named major,
            [minor|stacked_minor], y, [yerr, (ylo,yhi)]
    plotwith <plotnum|_ for latest,* for default> <with...>
    plottitle <plotnum|_ for latest> <title | notitle>
    axplusb <plotnum>
    default (table|where) <thing>
    psplot [--nocolor] [--mode={eps,portrait,landscape=default}] [--fontsize=<int>] <filename>
    pngplot {psplot args} <filename> [width height]
    pngpsplot {psplot args} <base-filename> [width height]
    define ... enddefine
    source <filename>
    fncmds <code>
    import-data I<tablename> I<columns> ... -- I<files> ...
    help [I<command>]
    man
    exit or quit

=head1 COMMANDS

Commands can be inside of a file for input to mercury, or typed in at the
mercury prompt.  A command can be continued over multiple lines by putting \
and optional whitespace at the end of the line, lines after that will have
leading whitespace reduced to a single space.  This rule does not apply inside
of define blocks.  The following commands can be used in mercury-plot:

=cut


### QUESTION: Should this all be replaced by a bunch of objects
### QUESTION: that have methods, so that extensibility is easier?

sub docmd {
    local $_ = shift;

    if ($define_mode) {
	if(/^enddefine$/o) {
	    $prompt = ">> ";
	} else {
	    push(@define,"$_\n");
	    return;
	}
    }
    if ($Global::continuation_cmd ne '') {
	s/^\s+/ /o;
    }
    if (s/\\\s*$//o) {
	$Global::continuation_cmd .= $_;
	$prompt = "... ";
	return;
    } else {
	$_ = "$Global::continuation_cmd$_";
	$Global::continuation_cmd = '';
	$prompt = ">> ";
    }
    if (defined $markerre) {
	if ($_ =~ $markerre) {
	    print "skip>> $_\n";
	    $markerre = undef;
	    $prompt = ">> ";
	}
	return;
    }
    s/^\s+//o; # allow for indendation
    if (/^select\s+/o) {
	push(@history,$_);
	sqlselect($_);
    } elsif (/^htmlselect /o) {
	push(@history,$_);
	htmlselect($_);
    } elsif (/^sql\s+(\S.*)$/o) {
	push(@history,$_);
	sqlcmd($1);
    } elsif (/^default\s+(\S.+)$/o) {
	push(@history,$_);
	default($1);
    } elsif (/^plot /o) {
	push(@history,$_);
	sqlplot($_);
    } elsif (/^barplot /o) {
	push(@history,$_);
	barplot($_);
    } elsif (/^fnplot\s+(.+)/o) {
	push(@history,$_);
	fnplot($1);
    } elsif (/^unplot\s*(\d+)?$/o) {
	push(@history,$_);
	unplot($1);
    } elsif (/^replot$/o) {
	push(@history,$_);
	replot();
    } elsif (/^listplot$/o) {
	listplot;
    } elsif (/^plotwith\s+((?:\d+)|(?:_)|(?:\*))\s+(\S.*)$/o) {
	push(@history,$_);
	plotwith($1,$2);
    } elsif (/^plottitle\s+((?:\d+)|(?:_))\s+(\S.*)$/o) {
	push(@history,$_);
	plottitle($1,$2);
    } elsif (/^gnuplot\s+(\S.*)$/o) {
	push(@history,$_);
	gnuplot($1);
    } elsif (/^pngplot\s+(\S.*)$/o) {
	push(@history,$_);
	pngplot(0,$1);
    } elsif (/^pngpsplot\s+(\S.*)$/o) {
	push(@history,$_);
	pngplot(1,$1);
    } elsif (/^psplot\s+(\S.*)$/o) {
	push(@history,$_);
	psplot($1);
    } elsif (/^help$/o) {
	help;
    } elsif (/^pause\s+(.+)$/o) {
	push(@history,$_);
	pause($1);
    } elsif (/^help\s+(.+)$/o) {
	help($1);
    } elsif (/^history skipto (\w+)\s*$/o) {
	my $marker = $1;
	$markerre = qr/^\s*history marker $marker\s*$/;
	print "skip>> ...\n";
	$prompt = "skip>> ";
    } elsif (/^history\s+(.+)$/o) {
	push(@history,$_);
	history($1);
    } elsif (/^source\s+(.+)$/o) {
	push(@history,$_);
	history("run $1");
    } elsif (/^exit$/o || /^quit$/o) {
	saveexit;
    } elsif (/^axplusb\s+(\d+)$/o) {
	push(@history,$_);
	axplusb($1);
    } elsif (/^define$/o) {
	push(@history,$_);
	warn "Already in define mode!\n" if $define_mode;
	$define_mode = 1;
	$prompt = "define>> ";
    } elsif (/^enddefine$/o) {
	push(@history,$_);
	if (!$define_mode) {
	    warn "Not in define mode!\n";
	    return;
	}
	eval join('',"package MercuryEval;\n",@define);
	if ($@) {
	    warn "Define failed: $@\n";
	    $command_error = 1;
	}
	@define = ();
	$define_mode = 0;
    } elsif (/^fncmds\s+(\S.+)$/o) {
	fncmds($1);
    } elsif (/^\S.+\(.*\)/o) {
	fncmds($_);
    } elsif (/^\s*$/o || /^\#/o) {
	# ignore
    } elsif (/^man$/o) {
	pod2usage(-verbose => 2, -exitval => 'NOEXIT');
    } elsif (/^import-data\s+(\S.+)\s+--\s+(\S.+)$/o) {
	import_data($1,$2);
    } else {
	print "Unknown command '$_'; try help or man\n";
	$command_error = 1;
    }
    shift @history if @history > 100;
    syncToGnuplot() if defined $gnuplot_fifo;
}

my @plots;

sub refresh_plot {
    my $t;
    my @foo = map { $t = qq!$_->{data} ! if defined $_->{data};
		    $t = qq!$_->{function} ! if defined $_->{function};
		    $t .= " axes $_->{axes} " if defined $_->{axes}; 
		    $t .= defined $_->{title} ? qq!title "$_->{title}"! : "notitle";
		    $t .= " with $_->{with}" if defined $_->{with};
		    $t = $_->{explicit} if defined $_->{explicit};
		    $t; } @plots;
    &start_gnuplot;
    if (@foo == 0) {
	print $gnuplot_fifo "plot x\n";
    } else {
	print $gnuplot_fifo "plot ", join(", ",@foo), "\n";
    }
    syncToGnuplot();
}

=pod

=head2 plot I<sql select arguments>

C<plot> is the primary command that generates plots in
C<mercury-plot>.  It takes as an argument a generic sql statement with
the expectation that some of the columns will have special names that
it will use in order to generate the plot.  In this version, the
special names are x, y, y2, yerr, ylo, yhi, cdf.  A plot with x, y
will generate a simple scatter or line plot.  Using y2 instead of y
will plot against the second axis on the plot.  Adding in yerr will
add in error bars, and explicit tops and bottoms for the error bars
can be generated with ylo and yhi.  cdf will generate a cumulative
distribution function plot from a single plot value.

=head3 a few examples 

	plot step as x, nluns as y where variant = 1
	plot iosize as x, max(iops) as y where runcount = 1 and stripesize = 256 group by iosize
	plot iosize as x, avg(iops) as y, stddev(iops) as yerr where runcount = 1 group by iosize

=cut

# TODO: make plot able to handle barplot plots also.
sub sqlplot {
    my $cmd = shift;

    $cmd = &adjust_sql($cmd);
    if ($cmd =~ /\border\b/o) {
	# Leave it alone, user specified order, plot goes in that order.
    } elsif ($cmd =~ /\bcdf\b/o) {
	if ($cmd =~ s/\blimit\b/ order by cdf limit /o) {
	} else {
	    $cmd .= " order by cdf";
	}
    } elsif ($cmd =~ /\bseg_x1\b/o) {
	# no adjustment
    } elsif ($cmd =~ s/\blimit\b/ order by x limit /o) {
    } else {
	$cmd .= " order by x";
    }
    $cmd =~ s/^plot /select /o;
    my $sth = eval {sql_exec($cmd) };
    if ($@) {
	print "$@\n";
	$command_error = 1;
	return;
    }
    if ($sth->rows == 0) {
	print "No rows return by query $cmd\n";
	return;
    }
    my @names = @{$sth->{NAME}};
    my ($x,$y,$y2,$yerr,$ylo,$yhi,$cdf, $seg_x1, $seg_y1, $seg_x2, $seg_y2);
    my %known_columns = ( 'x' => \$x, 'y' => \$y, 'y2' => \$y2, 
			  'yerr' => \$yerr, 'ylo' => \$ylo, 'yhi' => \$yhi,
			  'cdf' => \$cdf, 
			  'seg_x1' => \$seg_x1, 'seg_y1' => \$seg_y1, 
			  'seg_x2' => \$seg_x2, 'seg_y2' => \$seg_y2);
    my %found;
    for(my $i=0;$i<@names;++$i) {
	my $t;
	if (defined $known_columns{$names[$i]}) {
	    $sth->bind_col($i+1,$known_columns{$names[$i]});
	    $found{$names[$i]} = $known_columns{$names[$i]};
	} else {
	    warn "Don't know how to plot column name $names[$i]\n";
	}
    }
    my $writefn;
    my $plotfn;
    my $filename = "/tmp/.plot.data.$$-$plotfiles";
    unless(open(OUT,">$filename")) {
	print "Unable to open $filename for write: $!\n";
	return;
    }

    if (0) {
    } elsif ($found{x} && $found{y} && $found{yerr}) {
	$writefn = sub { print OUT "$x $y $yerr\n"; };
	$plotfn = \&plotxy_yerr;
    } elsif ($found{x} && $found{y} && $found{ylo} && $found{yhi}) {
	$writefn = sub { print OUT "$x $y $ylo $yhi\n"; };
	$plotfn = \&plotxy_yhilo;
    } elsif ($found{x} && $found{y}) {
	$writefn = sub { print OUT "$x $y\n"; };
	$plotfn = \&plotxy;
    } elsif ($found{x} && $found{y2} && $found{yerr}) {
	$writefn = sub { print OUT "$x $y2 $yerr\n"; };
	$plotfn = \&plotxy2_yerr;
    } elsif ($found{x} && $found{y2} && $found{ylo} && $found{yhi}) {
	$writefn = sub { print OUT "$x $y2 $ylo $yhi\n"; };
	$plotfn = \&plotxy2_yhilo;
    } elsif ($found{x} && $found{y2}) {
	$writefn = sub { print OUT "$x $y2\n"; };
	$plotfn = \&plotxy2;
    } elsif ($found{cdf}) {
	my $nrows = $sth->rows;
	my $i = 0;
	$writefn = sub { printf OUT "%.4f $cdf\n", 100*$i/$nrows; ++$i };
	$plotfn = \&plotxy;
    } elsif ($found{seg_x1} && $found{seg_y1} 
	     && $found{seg_x2} && $found{seg_y2}) {
	$writefn = sub { printf OUT "$seg_x1 $seg_y1\n$seg_x2 $seg_y2\n\n"; };
	$plotfn = \&plotseg;
    } else {
	print "Don't know how to plot results.\n";
	return;
    }
    my $warned = 0;
    FETCH: while(defined $sth->fetch) {
	while(my($k,$v) = each %found) {
	    if (!defined $$v) {
		warn "Null values returned by query.\n"
		    unless $warned;
		$warned = 1;
		next FETCH;
	    }
	}
	&$writefn;
    }
    close(OUT);
    my $newp = &$plotfn($filename,$cmd);
    push(@plots,$newp);
    refresh_plot;
    ++$plotfiles;
}

sub barplotColors {
    my ($colors) = @_;

    # In Postscript:
    # pattern 1: wide cross, pattern 2: narrow cross, pattern 3: black, pattern 4: wide backslash
    # pattern 5: wide forward slash, pattern 6: narrow backslash, pattern 7: narrow forwardslash
    # pattern 8: white

    if ($colors eq 'color') {
	return ('');
    } elsif ($colors eq '6-grays') {
	$colors = 'p1,g0.00, p2,g0.20, p4,g0.40, p5,g0.60, p6,g0.80, p7,g1.00';
    } elsif ($colors eq '4-grays') {
	$colors = 'p1,g0.00, p2,g0.33, p4,g0.66, p5,g1.00';
    }

    my @ret;
    foreach my $ent (split(/,\s*/o, $colors)) {
	if ($ent =~ /^p(\d+)$/o) {
	    push(@ret, "fs pattern $1 lt -1");
	} elsif ($ent =~ /^g(\d+\.\d+)$/o) {
	    push(@ret, "fs solid $1 lt -1");
	} else {
	    die "Unable to interpret color '$ent', expected p# or g#.##";
	}
    }

    return @ret;
}

=pod

=head2 barplot [--color=I<color>] I<sql select arguments>

C<barplot> is the command that generates bar-style plots for C<mercury-plot>.
It takes as an argument the part of an sql statement after the select.  Two
columns are required, major and y.  There are a number of optional columns:
minor or stacked_minor, yerr, and ylo/yhi.  The major columns are separated and
the minor columns are grouped or stacked together.  The barplot actually
generates a series of plots, one for each of the minor variables, or 1 if there
is no minor variable or the plot is stacked.  The bars are ordered in the same
way that they come back from the sql query, so sql's C<order by> can be used to
control the order.  For stacked charts the yerr, ylo and yhi columns will be
ignored.  Mercury-plot will automatically set important gnuplot options like
the key to 'autotitle columnheader invert', and the style options to histogram
and rowstacked.  Note that stacked bar charts were added to gnuplot 4.2, so
will not work with earlier versions.  Mercury will not protect you against this
issue.

The color option allows you to specify the colors to be used in the stacked bar
graph.  There are three meta-specifications: color, 6-grays, and 4-grays.
These specify the use of color, alternating patterns and grayscale with six
grays, or alternating patterns and grayscale with four grays respectively.  You
can also explicitly specify the pattern and solid colors to use.  This is done
by specifying values of either pI<#> to use gnuplot pattern #, or gI<#.##> to
specify the use of solid grayscale with density #.##.

=head3 a few examples

	barplot time as y, timestddev as yerr, querygroup as major, engine as minor from tmp_ds_barplot where position > 0 order by position
	barplot time as y, timestddev as yerr, querygroup as major, engine as stacked_minor from tmp_ds_barplot where position > 0 order by position
	barplot --color=4-grays time as y, timestddev as yerr, engine as major from tmp_ds_barplot order by position

=cut

sub barplot {
# plots a bar-graph with bars for each  "minor" attribute clustered togeter and the clusters for each "major" attribute seperated.
    # some constants
    my $box_width=0.9;
    my $group_separation=3;

    $_ = $_[0];
    die "Bad args to barplot"
	unless m!barplot\s+(.+)$!o;
    my $select = $1;

    my $color = '4-grays';
    if ($select =~ s/^--color=(\S+)\s+//o) {
	$color = $1;
    }
    my %data;

    # Collect all the data we want.
    $select = &adjust_sql("select $select");
    my $sth = sql_exec($select);
    my @minor_value_list;
    my %minors;
    my @major_value_list;
    my %majors;
    while(my $href = $sth->fetchrow_hashref()) {
	my $major = $href->{major};
	die "missing major column, or got null value from '$select'"
	    unless defined $major;

	push(@major_value_list, $major) # preserve order from query
	    unless defined $majors{$major};
	$majors{$major} = 1;

	my $y = $href->{y};
	die "Missing y column, or got null value from '$select'"
	    unless defined $y;

	my ($ylow, $yhi);

	if (defined $href->{yerr}) {
	    ($ylow,$yhi) = ($y - $href->{yerr}, $y + $href->{yerr});
	} elsif (defined $href->{ylo} || defined $href->{yhi}) {
	    die "Missing one of ylo or yhi, or got null value from '$select'"
		unless defined $href->{ylo} && defined $href->{yhi};
	    ($ylow,$yhi) = ($href->{ylo}, $href->{yhi});
	} else {
	    ($ylow,$yhi) = ($y,$y);
	}

	if (defined $href->{minor} || defined $href->{stacked_minor}) {
	    my $minor = $href->{minor} || $href->{stacked_minor};
	    die "got null value in minor column from '$select'"
		unless defined $minor;
	    die "duplicate value for $major / $minor from '$select'?"
		if defined $data{$major}->{$minor};
	    $data{$major}->{$minor} = { 'y' => $y, 'ylow' => $ylow, 'yhi' => $yhi };
	    push(@minor_value_list, $minor)
		unless defined $minors{$minor}; # preserve order from query
	    $minors{$minor} = 1;
	} else {
	    die "duplicate value for $major from '$select'?"
		if defined $data{$major}->{y};
	    $data{$major} = { 'y' => $y, 'ylow' => $ylow, 'yhi' => $yhi };
	}
    }

    my $warned_zero;
    # Make sure we got everything before starting to make plots
    foreach my $major (@major_value_list) {
	if (@minor_value_list) {
	    foreach my $minor (@minor_value_list) {
		unless (defined $data{$major}->{$minor}) {
		    warn "Missing data for major=$major, minor=$minor; no further warnings"
			unless $warned_zero;
		    $warned_zero = 1;
		    $data{$major}->{$minor} = { y => 0, ylow => 0, yhi => 0};
		}
	    }
	} else {
	    unless (defined $data{$major}->{y}) {
		warn "Missing data for major=$major; no further warnings"
		    unless $warned_zero;
		$warned_zero = 1;
		$data{$major} = { y => 0, ylow => 0, yhi => 0};
	    }
	}
    }

    # Make the plots...

    # TODO: figure out how to detect the gnuplot version so that we can give an
    # error if we try to do stacked charts with old gnuplot versions.

    if (defined $sth->{NAME_hash}->{stacked_minor}) {
	my $filename = "/tmp/.plot.data.$$-$plotfiles";
	my $fh = new FileHandle(">$filename")
	    or die "Unable to open $filename for write: $!";

	# TODO: print warning on whitespace?
	print $fh join("\t", "MAJOR_AXIS", removeWhitespace(@minor_value_list)), "\n";
	foreach my $major (@major_value_list) {
	    print $fh join("\t", removeWhitespace($major), 
			   map { $data{$major}->{$_}->{y} } @minor_value_list), "\n";
	}

	my $p = default_plotinfo($filename, $select);
	# Use patterns in order 1,g0,2,g0.20,4,g0.40,5,g0.60,6,g0.80,7,g1.00
	# 
	my @colors = barplotColors($color);
	$p->{explicit} = join(", ", "'$filename' using 2:xtic(1) $colors[0]",
			      map { push(@colors, shift @colors); 
				    "'' using $_ $colors[0]" } 3..(@minor_value_list + 1));
	push(@plots, $p);
	++$plotfiles;
	# Lots of magic foo to feed to gnuplot to make it do the right thing.
	gnuplot("set key autotitle columnheader invert");
	gnuplot("set style data histogram");
	gnuplot("set style histogram rowstacked");
	gnuplot("set style fill solid border -1");
	gnuplot("set boxwidth 0.75");
    } else {
	my $have_minor = @minor_value_list;
	@minor_value_list = ("data") 
	    unless @minor_value_list;
	my $minor_index = 1;
	my $minor_length = scalar @minor_value_list;
	foreach my $minor (@minor_value_list) {
	    my $filename = "/tmp/.plot.data.$$-$plotfiles";
	    die "Unable to open $filename for write: $!"
		unless open(OUT,">$filename");

	    my $major_x = $minor_index;
	    foreach my $major (@major_value_list) {
		my $t;
		if ($have_minor) {
		    $t = $data{$major}->{$minor};
		} else {
		    $t = $data{$major};
		}
		print OUT "$major_x $t->{y} $t->{ylow} $t->{yhi} $box_width\n";
		$major_x += $minor_length + $group_separation;
	    }
	    close(OUT);
	    my $newp = plotboxes($filename,$minor,$select);
	    push(@plots,$newp);
	    ++$plotfiles;
	    ++$minor_index;
	}
	my $major_xtic = POSIX::ceil($minor_length/2.0) - ($minor_length + $group_separation);

	my $xtics_vals = join(", ", map { $major_xtic += $minor_length + $group_separation; 
					  "'$_' $major_xtic" } @major_value_list);

	gnuplot('set ticscale 0');
	gnuplot("set xtics ($xtics_vals)");
    }
    refresh_plot;
}


sub savehistory {
    my $fh = new FileHandle ">$history_file";
    if (defined $fh) {
	print $fh join("\n",@history),"\n";
	close($fh);
	print "Saved history to $history_file\n";
    } else {
	print "Warning, unable to save history to $history_file: $!\n";
    }
}

sub history {
    $_ = shift;

    if (/^save$/o) {
	savehistory;
    } elsif (/^clear$/o) {
	@history = ();
    } elsif (/^load\s+(.+)$/o) {
	my $fn = $1;
	my $fh = new FileHandle $fn;
	if (defined $fh) {
	    print "Loading history from $fn\n";
	    while(<$fh>) {
		chomp;
		$term->addhistory($_) if defined $term;
	    }
	} else {
	    print "Unable to open $fn: $!\n";
	}
    } elsif (/^run\s+(.+)$/o) {
	my $filename = $1;
	my $save_source_dir = $Global::source_dir;

	if (! -r $filename && -r "$Global::source_dir/$filename") {
	    print "Automatically adding $Global::source_dir to $filename\n";
	    $filename = "$Global::source_dir/$filename";
	}
	$Global::source_dir = dirname($filename);
	
	my $fh = new FileHandle $filename;
	if (defined $fh) {
	    print "Running history from $filename\n";
	    my @save_history = @history;
	    my $linenum = 0;
	    while(<$fh>) {
		++$linenum;
		next if /^#/o;
		next if /^\s*$/o;
		print "load>> $_" unless defined $markerre;
		chomp;
		eval { &docmd($_); };
		if ($@ || $command_error) {
		    print "Error evaluating line $linenum of $filename, terminating command loading: $@\n"
			if $@;
		    last;
		}
	    }
	    # Don't fill history with loaded data.
	    @history = @save_history;
	    if (defined $markerre) {
		print "Warning: didn't find history marker ...\n";
		$markerre = undef;
		$prompt = ">> ";
	    }
	} else {
	    print "Unable to open $1: $!\n";
	}
	close($fh);
	syncToGnuplot() if defined $gnuplot_fifo;
	$Global::source_dir = $save_source_dir;
    } elsif (/^marker\s+(\w+)$/o) {
	# marker; from probably commented out skipto.
    } else {
	chomp;
	print "Unknown command 'history $_'; try help history\n";
    }
}
		
sub saveexit {
    if (defined $gnuplot_fifo) {
	print $gnuplot_fifo "exit\n";
    }
    unlink("/tmp/.plot.fifo.$$");
    for(my $i=0;$i<$plotfiles;++$i) {
	unlink("/tmp/.plot.data.$$-$i");
    }
    savehistory;
    exit(0);
}
	
sub helphistory {
    print "history save\n";
    print "history clear\n";
    print "history load <filename> \# loads filename into history\n";
    print "history run <filename> \# runs comannds from filename\n";
    print "source <filename> \# same as history run <filename>\n";
    print "history skipto <markername> \# useful for scripts, skips ahead to a marker.\n";
    print "history marker <markername> \# useful associated with script.\n";
}

sub pause {
    my ($arg) = @_;
    if (@_ > 0) {
	print $gnuplot_fifo "pause $arg\n";
    } else {
	print $gnuplot_fifo "pause\n";
    }
    syncToGnuplot();
}

sub help {
    if (@_ > 0) {
	pod2usage(-verbose => 99, -sections => "COMMANDS/^$_[0]( .*)?\$", -exitval => 'NOEXIT');
    } else {
	pod2usage(-verbose => 2, -exitval => 'NOEXIT');
    }
}


my $default_table;
my $default_where;
my $default_plotwith;

sub MercuryEval::get_default_where {
    return $default_where;
}

sub adjust_sql {
    ($_) = @_;

    my $start = $_;
    # Sql form is select ... from ... where ... group ... having ... order ... limit ...

    if (defined $default_table) {
	unless(/\bfrom\b/o) {
	    if (s/\bwhere\b/ from $default_table where/o) {
	    } elsif (s/\bgroup\b/ from $default_table group/o) {
	    } elsif (s/\bhaving\b/ from $default_table having/o) {
	    } elsif (s/\border\b/ from $default_table order/o) {
	    } elsif (s/\blimit\b/ from $default_table limit/o) {
	    } else {
		$_ .= " from $default_table";
	    }
	}
    }
    if (defined $default_where) {
	if (s/\bwhere\s(.*?)(\b(group)|(having)|(order)|(limit)\b)/where ($default_where) and ($1) $2/o) {
	} elsif (s/\bwhere\s(.*)$/where ($default_where) and ($1)/o) {
	} elsif (s/\bgroup\b/ where ($default_where) group/o) {
	} elsif (s/\bhaving\b/ where ($default_where) having/o) {
	} elsif (s/\border\b/ where ($default_where) order/o) {
	} elsif (s/\blimit\b/ where ($default_where) limit/o) {
	} else {
	    $_ .= " where ($default_where)";
	}
    }
    print "Adjusted sql command (orig, adjusted):\n$start\n$_\n"
	if $_ ne $start;
    return $_;
}

sub default {
    $_ = shift;

    if (/^table\s+(\w+)$/o) {
	$default_table = $1;
	$default_table = undef if $default_table eq 'none';
	print "Set Default table to $default_table\n";
    } elsif (/^where\s+(.+)$/o) {
	$default_where = $1;
	$default_where = undef if $default_where eq 'none';
    } else {
	print "Unknown command 'default $_'
default table <tablename|none>
     or where <where-clause|none>
     table will be used if no from clause exists.
     where clause will always be added\n";
    }
}

sub sqlselect {
    local @ARGV = split(/ /o, $_);

    my $format = 'text-table';
    my $filename;

    die "?" unless $ARGV[0] eq 'select';
    for(my $i = 1; $i < @ARGV; ++$i) {
	unless ($ARGV[$i] =~ /^--/o) {
	    splice(@ARGV,$i,0,"--");
	    last;
	}
    }
    my $ret = GetOptions("format=s" => \$format,
			 "filename=s" => \$filename);
    unless ($ret) {
	print "select [--format={text-table,html}] [--filename=<path>] <sql select>\n";
	$command_error = 1;
	return;
    }
    my $cmd = join(' ', @ARGV);

    $cmd = &adjust_sql($cmd);
    my $sth = eval { sql_exec($cmd) };
    if ($@) {
	print "$@\n";
        $command_error = 1;
	return;
    }
    
    # Data::Showtable explicitly writes to STDOUT, grr.
    my $save_stdout;
    if (defined $filename) {
	$save_stdout = new FileHandle ">&STDOUT"
	    or die "Can't dup stdout: $!";
	unless(open(STDOUT, ">$filename")) {
	    print "Unable to open $filename for write: $!\n";
	    $command_error = 1;
	    return;
	}
    } 

    my $error;
    if ($format eq 'text-table') {
	sqlSelectTextTable($sth, ! defined $filename);
    } elsif ($format eq 'html') {
	sqlSelectHtml($sth);
    } else {
	$error = "Unknown format '$format', expected text-table or html\n";
    }
    if (defined $save_stdout) {
	open(STDOUT, ">&=", fileno($save_stdout))
	    or die "Unable to dup back to save_stdout: $!";
    }
    if (defined $error) {
	print STDERR $error;
	$command_error = 1;
    }
}

sub sqlSelectTextTable {
    my ($sth, $pager_ok) = @_;

    my $rows = $sth->rows;
    my @types = map { "text" } @{$sth->{NAME}};
    
    my @first_rows;
    my @widths;
    my $fetch_initial_rows = 1000;
    while(my @row = $sth->fetchrow_array) {
	@row = map { defined $_ ? $_ : '' } @row;
	push(@first_rows,\@row);
	for(my $i=0;$i<@row;++$i) {
	    $widths[$i] ||= 0;
	    $widths[$i] = length $row[$i] if length $row[$i] > $widths[$i];
	}
	last if @first_rows >= $fetch_initial_rows;
    }
    my $total_width = 0; map { $total_width += $_ } @widths;
    my $lesspid;
    if ($total_width * $rows > 50*80 && $pager_ok) {
	open(SAVESTDOUT,">&STDOUT");
	select(SAVESTDOUT);
	$lesspid = open(STDOUT,"| less");
	select(STDOUT);
	unless (defined $lesspid && $lesspid > 0) {
	    warn "Unable to start less; lots of output about to occur.\n";
	    sleep(2);
	    open(STDOUT,">&SAVESTDOUT") || die "Unable to un-redirect STDOUT: $!\n";
	    $lesspid = undef;
	}
    }
    push(@first_rows,[]) if @first_rows < $fetch_initial_rows;
    ShowBoxTable($sth->{NAME},\@types,\@widths,
		 sub { return undef if $_[0] == 1;
		       return @{shift @first_rows} if @first_rows > 0;
		       return map { defined $_ ? $_ : '' } $sth->fetchrow_array; });
    if (defined $lesspid) {
        close(STDOUT);
        waitpid ($lesspid,0);
        open(STDOUT,">&SAVESTDOUT") || die "Unable to un-redirect STDOUT: $!\n";
        select(STDOUT);
    }
}

sub sqlSelectHtml {
    my ($sth) = @_;

    # TODO: consider using HTML version of Data::ShowTable; check to see when 
    # it was added to make sure it will work on supported platforms.
    my $rows = $sth->rows;
    
    print "<TABLE BORDER=\"2\">\n";
    print "  <TR>\n   ";
    foreach my $header (@{$sth->{NAME}}) {
	print " <TH>$header</TH>";
    }
    print "\n  </TR>\n";
    while(my @row = $sth->fetchrow_array) {
	print "  <TR>\n   ";
	foreach my $v (@row) {
	    print " <TD>$v</TD>";
	}
	print " </TR>\n";
    }
    print "</TABLE>\n";
}

sub htmlselect {
    warn "htmlselect command is obsolete.  TODO: remove after 2011-01-01";
    my $cmd = shift;

    my $fh;
    if ($cmd =~ s/^htmlselect\s*-o\s*(\S+)\s+/htmlselect /o) {
	my $filename = $1;
	$fh = new FileHandle ">$filename" or die "Can't open $filename for write: $!\n";
    } else {
	$fh = *STDOUT;
    }
    $cmd =~ s/^html//o;
    $cmd = &adjust_sql($cmd);
    my $sth = eval { sql_exec($cmd) };
    if ($@) {
	print "$@\n";
	return;
    }
    
    my $rows = $sth->rows;
    my @types = map { "text" } @{$sth->{NAME}};
    
    my $oldfh = select($fh);
    print "<TABLE BORDER=\"2\">\n";
    print "  <TR>\n   ";
    foreach my $header (@{$sth->{NAME}}) {
	print " <TH>$header</TH>";
    }
    print "\n  </TR>\n";
    while(my @row = $sth->fetchrow_array) {
	print "  <TR>\n   ";
	foreach my $v (@row) {
	    print " <TD>$v</TD>";
	}
	print " </TR>\n";
    }
    print "</TABLE>\n";

    select($oldfh);
}

sub sqlcmd {
    my $cmd = shift;

    my $start = time;
    my $sth = eval {sql_exec($cmd) };
    if ($@) {
	print "$@\n";
	return;
    }
    my $end = time;
    printf "Affected %d rows in %.2fs\n" , $sth->rows, $end-$start;
}

sub removeWhitespace {
    my @ret = @_;

    map { s/\s+/_/go; } @ret;
    return @ret;
}

sub start_gnuplot {
    return if defined $gnuplot_fifo;
    print "Starting Gnuplot...\n";
    my $pty = new IO::Pty() or die "Unable to get a pty";
    my $slave = $pty->slave;
    my $pid = fork;
    if ($pid == 0) {
	  $pty->make_slave_controlling_terminal or die;
	  close $pty;
	  $slave->set_raw;
	  close STDIN;
	  open(STDIN, "<&".$slave->fileno) or die;
	  close STDOUT;
	  open(STDOUT, ">&".$slave->fileno) or die;
	  close STDERR;
	  open(STDERR, ">&".$slave->fileno) or die;
	  eval {exec "@GNUPLOT_PATH@";};
	  exit(1);
    }
    $pty->close_slave();
    select(undef,undef,undef,0.25); # wait a little for it to start.
    waitpid($pid,&WNOHANG);
    unless (kill (0,$pid) == 1) {
	  die "Unable to start gnuplot!\n";
    }
    print "done.\n";
    my $flags = fcntl($pty, F_GETFL, 0) or die;
    fcntl($pty, F_SETFL, $flags | O_NONBLOCK) or die;
    $gnuplot_fifo = $pty;
    $gnuplot_fifo->autoflush(1);
    # TODO: auto-detect if there is the wxt terminal and use that if possible;
    # also need to fix other uses of set terminal x11
    print $gnuplot_fifo "set terminal $gnuplot_terminal_type\n";
}

# The idea here is that we keep reading from gnuplot until we are able
# to send a return to it and have it "immediately" come back.  That
# condition indicates that it is likely that gnuplot is now done
# processing events.

sub syncToGnuplot {
    confess "gnuplot is not running" unless defined $gnuplot_fifo; 
    my $select = IO::Select->new();
    $select->add($gnuplot_fifo);

    my $started = time;
    my $max_delay = 60;
    my $last_warn = time;
    while(1) {
	my @ready = $select->can_read(0.1);
	if (@ready == 0) {
	    return if fastReplyFromGnuplot($select);
	    die "Waited $max_delay seconds for gnuplot to finish, aborting"
		if (time - $started) > $max_delay;
	    if ((time - $last_warn) > ($max_delay/10)) {
		my $waited = time - $started;
		$last_warn = time;
		warn "Warning, still waiting after $waited seconds for gnuplot to finish.\n";
	    }
	} else {
	    while (my $line = <$gnuplot_fifo>) {
		print $line;
	    }
	}
    }
}

# We send a return, we should get at most an echoed return and the
# next prompt.  We should get it quickly.  Anything else is wrong.
sub fastReplyFromGnuplot {
    my ($select) = @_;
    confess "gnuplot isn't running" unless defined $gnuplot_fifo;

    print "FRFG\n" if $debug;
    print $gnuplot_fifo "\n";
    my $max_reply_time = time + 0.05;
    my $continue = 1;
    while ($continue) {
	my $delay = $max_reply_time - time;
	if ($delay <= 0) { # we lose, too long waiting
	    print "Waited too long\n" if $debug;
	    return 0;
	}

	$select->can_read($delay);

	while (1) {
	    my $line = <$gnuplot_fifo>;
	    last unless defined $line;
	    print "Line\n" if $debug;
	    if ($line =~ /\s*\n$/o) {
		print $line;
		# ok
	    } elsif ($line =~ /^gnuplot> $/o) {
		# what we want, hide prompt
		$continue = 0;
		last;
	    } else {
		warn "Unexpected '$line'\n";
		return 0; # something else
	    }
	}
    }
    print "ExpectBlank\n" if $debug;
    my $line = <$gnuplot_fifo>;
    return 1 if ! defined $line; # and nothing after it, so we're good.
    print $line;
    return 0; # something else came in, not good.
}

sub gnuplot {
    &start_gnuplot;
    print $gnuplot_fifo "$_[0]\nreplot\n";
    syncToGnuplot(); 
}

sub psplot {
    my ($args) = @_;

    local @ARGV = split(/\s+/o,$args);
    my $mode = 'landscape';
    my $color = 1;
    my $fontsize = 18;
    my $success = GetOptions("mode=s" => \$mode,
			     "color!" => \$color,
			     "fontsize=i" => \$fontsize);
    if (@ARGV != 1 || $ARGV[0] =~ /\"/o 
	|| $mode !~ /^(eps)|(portrait)|(landscape)$/o) {
	print "Usage: psplot [--mode={eps,portrait,landscape=default}] [--nocolor] <filename>\n";
	print "ARGS: '@ARGV'\n";
	return 0;
    }
    
    my $use_color = $color ? "color" : "monochrome";
    print $gnuplot_fifo "set output \"$ARGV[0]\"\n";
    print $gnuplot_fifo "set terminal postscript $mode enhanced $use_color solid $fontsize\n";
    print $gnuplot_fifo "replot\n";
    print $gnuplot_fifo "set output\n";
    print $gnuplot_fifo "set terminal $gnuplot_terminal_type\n";
    syncToGnuplot(); 
    return 1;
}

sub pngplot {
    my ($save_ps,$args) = @_;

    $|=1;
    my @args = split(/\s+/o,$args);
    my ($width,$height) = (1024,768);
    if (@args >= 3 && $args[@args-1] =~ /^\d+$/o &&
	$args[@args-2] =~ /^\d+$/o) {
	$height = pop @args;
	$width = pop @args;
    }
    my $filename = pop @args;
    my $png_filename = $filename;
    $png_filename .= ".png" if $save_ps;
    unshift(@args,"--mode=eps");
    push(@args,"psplot-$$..ps");
    print "pngplot: psplot... ";
    unless (psplot(join(' ',@args))) {
	print "psplot to psplot-$$..ps failed; can't pngplot.\n";
	return 0;
    }
    syncToGnuplot();
    # Wait for stability on gnuplot writing the ps file...
    unless ($using_pty) {
	while(! -f "psplot-$$..ps") {
	    print "waiting(nops psplot-$$..ps)... ";
	    sleep(1);
	}
	my $cur_size = -s "psplot-$$..ps";
	while(1) {
	    print "waiting(size $cur_size)... ";
	    sleep(5);
	    last if $cur_size > 0 && $cur_size == -s "psplot-$$..ps";
	    $cur_size = -s "psplot-$$..ps";
	}
    }
    print "pstopnm... ";
    my $dblw = $width * 2;
    my $dblh = $height * 2;
    my $cmd = "@PSTOPNM_PATH@ -xsize $dblw -ysize $dblh -xborder .025 -yborder .025 psplot-$$..ps >err.$$ 2>&1";
    my $ret = system($cmd);
    if ($ret != 0) {
	print "Error running '$cmd'\n";
	$command_error = 1;
	return 0;
    }
    if (!-f "psplot-$$.001.ppm") {
	print "psplot or pstopnm error; didn't get psplot-$$.001.ppm\n";
	return 0;
    }
    if (-s "psplot-$$.001.ppm" < $dblw * $dblh * 3) {
	print "psplot or pstopnm error; psplot-$$.001.ppm too small\n";
	return 0;
    }
    if (-f "psplot-$$.002.ppm") {
	print "psplot or pstopnm error; got psplot-$$.002.ppm\n";
	return 0;
    }
    unlink ("err.$$");
    print "pnmscale... ";
    $cmd = "@PNMSCALE_PATH@ 0.5 psplot-$$.001.ppm >psplot-$$.001s.ppm";
    $ret = system($cmd);
    if ($ret != 0) {
	print "Error running '$cmd'\n";
	return 0;
    }
    if (-s "psplot-$$.001.ppm" < $width * $height * 3) {
	print "pnmscale error; psplot-$$.001s.ppm too small\n";
	return 0;
    }

    print "pnmtopng... ";
    $cmd = "@PNMTOPNG_PATH@ -compression 9 psplot-$$.001s.ppm >$png_filename";
    $ret = system($cmd);
    if ($ret != 0) {
	print "Error running '$cmd'\n";
	return 0;
    }
    if (-s $png_filename < 1000) {
	print "pnmtopng error; $png_filename too small\n";
	return 0;
    }
    print "done.\n";
    if ($save_ps) {
	unless(rename("psplot-$$..ps","${filename}.ps")) {
	    print "error in rename: $!";
	    return 0;
	}
    } else {
	unlink("psplot-$$..ps");
    }
    unlink("psplot-$$.001.ppm","psplot-$$.001s.ppm");
    return 1;
}

sub replot {
    my @save_plots = @plots;
    @plots = ();
    for(my $i=0;$i<@save_plots;++$i) {
	next unless defined $save_plots[$i]->{sql};
	sqlplot($save_plots[$i]->{sql});
	my $file = $plots[$i]->{data};
	$plots[$i] = $save_plots[$i];
	$plots[$i]->{data} = $file;
    }
    refresh_plot;
}

# See refresh_plot for valid bits in here.
sub default_plotinfo {
    my($filename, $sql_cmd) = @_;

    my $ret = { 'data' => qq!"$filename"!,
		'sql' => $sql_cmd,
		'title' => $sql_cmd };
    $ret->{'with'} = $default_plotwith if defined $default_plotwith;
    return $ret;
}

sub plotxy_yerr {
    my($filename, $sql_cmd) = @_;

    my $p = default_plotinfo($filename,$sql_cmd);
    $p->{with} = 'yerrorbars';
    return $p;
}

sub plotxy_yhilo {
    my($filename, $sql_cmd) = @_;

    my $p = default_plotinfo($filename,$sql_cmd);
    $p->{with} = 'yerrorbars';
    return $p;
}

sub plotxy {
    my($filename,$sql_cmd) = @_;

    return default_plotinfo($filename,$sql_cmd);
}

sub plotxy2_yerr {
    my($filename,$sql_cmd) = @_;

    my $p = default_plotinfo($filename,$sql_cmd);
    $p->{axes} = 'x1y2';
    $p->{with} = 'yerrorbars';
    gnuplot('set ytics nomirror');
    gnuplot('set y2tics');
    return $p;
}

sub plotxy2_yhilo {
    my($filename, $sql_cmd) = @_;

    my $p = default_plotinfo($filename,$sql_cmd);
    $p->{axes} = 'x1y2';
    $p->{with} = 'yerrorbars';
    gnuplot('set ytics nomirror');
    gnuplot('set y2tics');
    return $p;
}

sub plotxy2 {
    my($filename,$sql_cmd) = @_;

    my $p = default_plotinfo($filename,$sql_cmd);
    $p->{axes} = 'x1y2';
    gnuplot('set ytics nomirror');
    gnuplot('set y2tics');
    return $p;
}

sub plotboxes {
    my ($filename,$minor_value,$sql_cmd) = @_;   
    my $p = default_plotinfo($filename,$sql_cmd);
    $p->{with} = 'boxerrorbars';
    $p->{title} = $minor_value;
    return $p;
}

sub plotseg {
    my($filename,$sql_cmd) = @_;

    my $p = default_plotinfo($filename,$sql_cmd);
    $p->{with} = 'lines';
    return $p;
}

sub listplot {
    my $i = 0;
    foreach $_ (@plots) {
	print "$i: $_->{title}\n";
	++$i;
    }
}

sub unplot {
    my ($plotnum) = @_;

    &start_gnuplot;
    if (defined $plotnum) {
	splice(@plots,$plotnum,1);
    } else {
	@plots = ();
	print $gnuplot_fifo "reset\n";
	syncToGnuplot(); 
    }
    refresh_plot;
}

sub fnplot {
    my ($function) = @_;
    
    push(@plots,{ 'function' => $function,
		  'title' => $function });

    refresh_plot;
}

sub plotwith {
    my($plot,$with) = @_;

    if ($plot eq '*') {
	if ($with eq 'undef') {
	    $default_plotwith = undef;
	    return;
	}
	$default_plotwith = $with;
	print "default_plotwith = $default_plotwith\n";
	foreach my $plot (@plots) {
	    next if defined $plot->{with};
	    $plot->{with} = $default_plotwith;
	}
	refresh_plot;
	return;
    }
	
    $plot = @plots - 1 if ($plot eq '_');
    if ($plot > @plots) {
	print "No plot number $plot!\n";
	return;
    }
    $plots[$plot]->{with} = $with;
    refresh_plot;
}

sub plottitle {
    my($plot,$title) = @_;

    $plot = @plots - 1 if ($plot eq '_');
    if ($plot > @plots || $plot < 0) {
	print "No plot number $plot!\n";
	return;
    }
    if ($title =~ /\"/o) {
	print "Error: Title has \"'s in it, which will annoy gnuplot.\n";
	$command_error = 1;
	return 0;
    }
    $plots[$plot]->{title} = $title;
    delete $plots[$plot]->{title} if $title eq 'notitle';
    refresh_plot;
}

my $debug_axplusb = 0;

sub axplusb {
    my ($plot) = @_;

    if ($missing_statistics_ols) {
	print "do not have Statistics::OLS installed, unable to perform axplusb calculation\n";
	print "error on use was: $missing_statistics_ols\n";
	return;
    }
    if ($plot >= @plots) {
	print "No plot number $plot!\n";
	return;
    }
    if ($plots[$plot]->[0] !~ /^\"(.+)\"$/o) {
	print "Plot number $plot isn't a data plot??\n";
	return;
    }
    my $filename = $1;
    if (! -r $filename) {
	print "Plot number $plot gives filename $filename, but the file is gone??\n";
	return;
    }
    open(FILE,$filename) || die "Unable to read $filename: $!\n";
    my @x;
    my @y;
    while(<FILE>) {
	if (!/^(\S+) (\S+)$/o) {
	    chomp;
	    print "Unknown line '$_' in $filename\n";
	    return;
	}
	push(@x,$1);
	push(@y,$2);
    }

    my $npoints = @x;
    if ($npoints < 3) {
	print "Not enough points to do fit.\n";
	return;
    }
    $|=1;
    my $ls = new Statistics::OLS;
    my $best_split = -1;
    my $best_sigma = 100;
    my ($best_la,$best_lb,$best_ra,$best_rb);
    for (my $i=0;$i<$npoints;++$i) {
	# Point $i goes to the left.
	print "Try fit with split at $i ... "
	    if $debug_axplusb;
	

	my ($sigma_left, $l_a,$l_b);
	my @tx = @x[0..$i];
	my @ty = @y[0..$i];
	if (@tx >= 3) {
	    $ls->setData(\@tx,\@ty) || die "Failed1" . $ls->error();
	    $ls->regress() || die "Failed2" . $ls->error();
	    $sigma_left = $ls->sigma();
	    ($l_b,$l_a) = $ls->coefficients();
	    printf("left=%.6f * x + %.6f, %.6f ",$l_a,$l_b,$sigma_left)
		if $debug_axplusb;
	}

	my ($sigma_right,$r_a,$r_b);
	@tx = @x[$i+1..$npoints-1];
	@ty = @y[$i+1..$npoints-1];
	if (@tx >= 3) {
	    $ls->setData(\@tx,\@ty) || die "Failed3";
	    $ls->regress() || die "Failed4";
	    $sigma_right = $ls->sigma();
	    ($r_b,$r_a) = $ls->coefficients();
	    printf("right=%.6f * x + %.6f, %.6f ",$r_a,$r_b,$sigma_right)
		if $debug_axplusb;
	} 

	$sigma_left = $sigma_right unless defined $sigma_left;
	$sigma_right = $sigma_left unless defined $sigma_right;

	my $sigma_sum = $sigma_left + $sigma_right;

	if ($sigma_sum < $best_sigma) {
	    print "**BEST**"
		if $debug_axplusb;
	    $best_split = $i;
	    $best_sigma = $sigma_sum;
	    $best_la = $l_a;
	    $best_lb = $l_b;
	    $best_ra = $r_a;
	    $best_rb = $r_b;
	}
	print "\n"
	    if $debug_axplusb;
    }
    if ($best_split>= 0) {
	$best_sigma = sprintf("%.6f",$best_sigma);
	print "Found best ($best_sigma) as: ";
	if (defined $best_la) {
	    printf("0..$best_split = %.6f * x + %.6f ",$best_la,$best_lb);
	} else {
	    print "0..$best_split = n/a ";
	}
	if (defined $best_ra) {
	    printf("%d..%d = %.6f * x + %.6f ",$best_split+1,$npoints-1,
		   $best_ra,$best_rb);
	} else {
	    printf("%d..%d = na ",$best_split+1,$npoints-1);
	}
	print "\n";
    }
}

sub fncmds {
    my($cmd) = @_;

    my $result = eval("package MercuryEval;\n$cmd");
    if ($@) {
	warn "fncmds ($cmd) failed: $@\n";
	$command_error = 1;
	return;
    }
    my @result = split(/\n/o,$result);
    foreach my $i (@result) {
	next if $i =~ /^\s*$/o;
	print "fncmds>> $i\n";
	eval { &docmd($i); };
	if ($@) {
	    print "Error executing function command: $@\n";
	    $command_error = 1;
	}
	last if $command_error;
    }
}

sub import_data {
    my ($columns, $files) = @_;

    my @columns = split(/\s+/o, $columns);
    my @files = split(/\s+/o, $files);

    if (@columns < 2 || @files < 1) {
	die "Missing table name, columns or files arguments";
    }

    foreach my $column (@columns) { 
	die "Bad column name $column" unless $column =~ /^\w+$/o;
    }
    my $table_name = shift @columns;
    foreach my $file (@files) {
	die "$file isn't readable" unless -r $file;
    }

    my %types;
    map { $types{$_} = { } } @columns;
    foreach my $file (@files) {
	my $fh = new FileHandle $file or die "Can't open $file for read: $!";
	while(<$fh>) {
	    chomp;
	    my @parts = split(/\s+/o);
	    die "Mismatch on column count in file $file, line: $_"
		unless @parts == @columns;
	    for (my $i=0; $i < @parts; ++$i) {
		my $column = $columns[$i];
		if ($parts[$i] =~ /^\d+$/o) { 
		    $types{$column}->{bigint} = $parts[$i];
		} elsif ($parts[$i] =~ /^\d+\.\d+$/o) {
		    $types{$column}->{double} = $parts[$i];
		} elsif (length $parts[$i] < 256) {
		    $types{$column}->{varchar} = $parts[$i];
		} else {
		    $types{$column}->{longtext} = $parts[$i];
		}
	    }
	}
	close($fh);
    }

    my @sql_columns;
    foreach my $column (@columns) {
	if (defined $types{$column}->{longtext}) {
	    print "$column: inferred longtext type from $types{$column}->{longtext}\n";
	    $types{$column} = 'text';
	    push(@sql_columns, "$column longtext not null");
	} elsif (defined $types{$column}->{varchar}) {
	    print "$column: inferred varchar type from $types{$column}->{varchar}\n";
	    $types{$column} = 'varchar';
	    push(@sql_columns, "$column varchar(255) not null");
	} elsif (defined $types{$column}->{double}) {
	    print "$column: inferred double type from $types{$column}->{double}\n";
	    $types{$column} = 'double';
	    push(@sql_columns, "$column double not null");
	} elsif (defined $types{$column}->{bigint}) {
	    print "$column: inferred bigint type from $types{$column}->{bigint}\n";
	    $types{$column} = 'bigint';
	    push(@sql_columns, "$column bigint not null");
	} else {
	    die "no type for $column";
	}
    }

    my $drop = "drop table if exists $table_name";
    print "$drop\n";
    sql_exec($drop);

    my $create = "create table $table_name (" . join(", ", @sql_columns) . ")";
    print "$create\n";
    sql_exec($create);

    my $insert = "insert into $table_name values (" . join(", ", map { "?" } @columns) . ")";
    print "$insert\n";
    my $sth = sql_prepare($insert);
    my $row_count = 0;
    foreach my $file (@files) {
	my $fh = new FileHandle $file or die "Can't open $file for read: $!";
	while(<$fh>) {
	    ++$row_count;
	    chomp;
	    my @parts = split(/\s+/o);
	    my $rc = eval { $sth->execute(@parts); };
	    die "insert failed: $@" if $@;
	    die "insert failed: $rc" unless $rc == 1;
	}
	close($fh);
    }
    print "imported $row_count rows\n";
}

__END__

=pod 

=head2 plottitle I<which> I<title>

C<plottitle> is the command to set a plot's title.  I<which> can
either be _ to specify the most recent plot or a number to specify the
plot number (counting from 0).  Using the special value notitle for
the I<title> will hide the title.  You can't put " in the title, as it 
doesn't work with gnuplot.

=head2 psplot [--nocolor] [--mode={eps,portrait,landscape}] [--fontsize=<int>] I<filename>

C<psplot> is the primary output mechanism in mercury-plot.  It
generates an output filename based on the currently plotted data.  The
options behave as expected; C<--nocolor> forces a monochrome plot.
C<--mode=...> selects a mode for the plot, the default is landscape,
and C<--fontsize=...> specifies a fontsize.

=head2 pngplot I<psplot arguments> I<filename> [I<width> I<height>]

C<pngplot> generates a png version of the currently displayed graph by
first generating postscript and then converting it to png.  This
method avoids the problem of getting different output from the ps and
png drivers in gnuplot.  The default width x height is 1024x768

=head2 pngpsplot I<psplot arguments> I<basename> [I<width> I<height>]

C<pngpsplot> generates both I<basename>.ps and I<basename>.png, it is
as if the obvious pair of pngplot and psplot commands were executed,
but it runs more efficiently since it only has to generate the
postscript once.

=head2 default table I<tablename>

Sets the default table for plot commands so that it does not need to
be repeated on every line.

=head2 default where I<sql where clause>

Sets the default where clause for plot commands so that it does not
need to be repeated on every line.  Can be combined with additional
where clauses on the individual plot lines so that this acts as a poor
mans table view.  For example: C<default where Disk = 6 and op = 'read'>

=head2 gnuplot I<gnuplot command>

Sends some command directly through to gnuplot for processing, for example:
C<gnuplot set logscale x>, or C<gnuplot set yrange [40:600]>

=head2 define ... enddefine 

Takes the block of code between the define and enddefine and evals it
in a separate namespace for use in mercury.  Useful for defining
functions that may do complicated things, or even simple ones that act
mostly as macros.  Example:

    define

    sub fooplot {
        my($where) = @_;
        return "select speed as x, enginetemp as y from engine_measurements where $where";
    }

    enddefine

    fooplot("engine = 'formula-1'")
    fooplot("engine = 'prius'")
    fooplot("engine = 'solid booster rocket'")

There are a number of perl functions that are useful inside of defined
functions:

=head3 sql_exec("sql")

Executes the sql and returns a DBI statement handle as a return (see
perldoc DBI).  Normally what you then want to do is use
$sth->fetchrow_array.  For example:

    my $sth = sql_exec("select expname, count(*) from experiments");
    while(my @row = $sth->fetchrow_array) {
       print "Experiment $row[0] has $row[1] experiments\n";
    }

=head3 sql_unique_row("sql")

Executes the sql and returns the unique row that came back (or fails
if you don't get a unique row).  For example:

    my($nexps, $max_runtime) = sql_unique_row("select count(*), max(runtime) from experiments");
    print "Over $nexps, the longest took $max_runtime seconds.\n";

=head2 I<fnname>(...)

Calls a function that was defined by the user in a define
... enddefine block.  While you can define functions that have the
same name as the built in commands since mercury-plot can tell the
difference by the (), you probably shouldn't, it would be confusing.

=head2 import-data I<table-name> I<column-name> ... -- I<filename> ...

Imports the data from the specified filenames into SQL, assumes that
the original data is space separated.  Auto infers column types of
bigint, double, varchar(255), longtext from the contents of the files.

=head1 TO FIX

=over 4

=item * Merge the barplot and plot commands since they now take the
same style arguments and are distinguishable by the existance of a
major column.

=item * Figure out how to have man <command> work properly, and
eventually consider replacing help with something that just extracts
from the pod documentation.

=back

