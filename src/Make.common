#
#  (c) Copyright 1999-2005, Hewlett-Packard Development Company, LP
#
#  See the file named COPYING for license details
#
# Common Makefile constructs

### Need to use gmake on this makefile

# Give an error if users don't provide a real default target before including
.PHONEY: defaulterror
defaulterror:
	$(error error: provide a default target before including Make.common)

### get OS type automatically
OS := $(shell uname -s)

### Setup compiler options. Set them to "bad" values first so that we get an
### error if someone trys this on an unknown OS
CC := echo "Unrecognized OS";false
CXX := $(CC)

# This provides a default for where to find SSP include files. This
# should be overridden if you're using Makefiles in subdirectories.
ifndef PREFIX
    PREFIX := ..
endif

COMMON_CPPFLAGS := -I$(PREFIX)/include -I/opt/local/include 
LINK_FLAGS := -L. -L$(PREFIX)/lib -L/opt/local/lib

ifeq ($(OS),HP-UX)
    CC := cc -Ae
    # What the aCC flags mean:
    #       -Aa   -> turn on all ANSI features
    #       -AA   -> turn on newer C++ features
    #       +p    -> disallow anachronistic constructs
    #       -z    -> trap null pointer dereferences
    #       +w    -> warn about questionable constructs
    #       +W361 -> disable "function might not return a value" warning.
    #       +W392 -> disable "conversion unnecessary" warning.
    #       +W655 -> disable "does not have any non-inline, non-pure virtual 
    #			member functions" warning.
    #       +W469 -> disable "useless typedef" warning.
    #       +W495 -> disable "linkage directive ignored for static obj/fn" 
    #			warning.
    #	    +W684 -> disable "integer constant -1 ... out of range"
    # The +W disable arguments are necessary as they are trigged by the system
    # include files (i.e. we have no control over them). Hopefully someone on
    # the aCC team will manage to fix the system files sometime, and these
    # will go away...
    CXX := aCC -Aa +p -z +w +W361,392,431,469,495,655,684 -D__HPACC_STRICTER_ANSI__

    # -D_INCLUDE_LONGLONG enables the use of 64-bit iostreams 
    COMMON_CPPFLAGS += -DHPUX_ACC -D_INCLUDE_LONGLONG -Dstd=
 
    # We have special include files for HP-UX that live in hp_replace
    COMMON_CPPFLAGS += -I$(PREFIX)/include/hp_replace 
    COMMON_CFLAGS := -Wl,+vnocompatwarnings 
    COMMON_FLAGS := $(COMMON_CPPFLAGS) $(COMMON_CFLAGS)

    # YACC_* are for yacc generated programs 
    YACC_FLAGS := +W600,612,818,829
    YACC_LIBS := -ll -ly 

    # flags for each of the common object categories
    DEBUG_FLAGS := $(COMMON_FLAGS) -DCOMPILE_DEBUG -g
    OPTIMIZE_FLAGS := $(COMMON_FLAGS) -DCOMPILE_OPTIMIZE +O2 +Onolimit
    PROFILE_FLAGS := $(OPTIMIZE_FLAGS) -DCOMPILE_PROFILE -G 

    LIBGC_DEBUG += -ldld
    LIBGC_PROFILE += -ldld
    LIBGC_OPTIMIZE += -ldld
    LIBS += -L/opt/local/lib 

    OS_REVISION := $(shell uname -r)

    # Used to link with -ldce, but that seems to cause problems on HPUX
    # 11.00 Everybody gets linkage with dce or pthread, doesn't seem like
    # that's quite right anymore.
    # FIXME: this will break with unknown OS versions.

    ifeq ($(OS_REVISION),B.10.20)
        PTHREAD_LIBS := -ldce
    endif
    ifeq ($(OS_REVISION),B.11.00)
        PTHREAD_LIBS := -lpthread
    endif
    PTHREAD_FLAGS := -D_POSIX_C_SOURCE=199506L -D_HPUX_SOURCE
endif

ifeq ($(OS),Linux)
    CC := gcc -Wall
    CXX := g++ -Wall
    COMMON_CPPFLAGS += -DLINUX_GCC -D_GNU_SOURCE
    COMMON_FLAGS := $(COMMON_CPPFLAGS) $(COMMON_CFLAGS)
    LIBS += -lpthread
	
    YACC_FLAGS :=
    YACC_LIBS := -lfl
    DEBUG_FLAGS := $(COMMON_FLAGS) -DCOMPILE_DEBUG -g 
    OPTIMIZE_FLAGS := $(COMMON_FLAGS) -DCOMPILE_OPTIMIZE -march=i686 -D__pentiumpro__ -O2 -g
    PROFILE_FLAGS := $(OPTIMIZE_FLAGS) -DCOMPILE_PROFILE -pg 
    PROFILE_LINK_FLAGS := -static
    PTHREAD_LIBS :=
    PTHREAD_FLAGS := -D_REENTRANT -D_XOPEN_SOURCE=500
endif

.PHONEY: clean install install-docs


### Define variables that can be used to create standard targets for most
### things that are commonly built. See Lintel documentation for full details
### In many of these, ld is run to build foo~, which is then moved to foo. This
### allows ld to keep running even if foo is being debugged (and is thus
### open for writing).

debug_program_target = $(1)-debug: $($(1)_objs:.o=.Do) $($(1)_deps); \
	$(CXX) $(CFLAGS) $(DEBUG_FLAGS) $(LINK_FLAGS) -o $(1)-debug~ $($(1)_objs:.o=.Do) $($(1)_libs) || exit 1; \
	[ ! -f $(1)-debug ] || mv $(1)-debug $(1)-debug.old; \
	mv $(1)-debug~ $(1)-debug; \
	rm -f $(1)-debug.old

profile_program_target = $(1)-profile: $(patsubst %-debug.a,%-profile.a,$($(1)_objs:.o=.Po)) $(patsubst %-debug.a,%-profile.a,$($(1)_deps)); \
	$(CXX) $(CFLAGS) $(PROFILE_FLAGS) $(PROFILE_LINK_FLAGS) $(LINK_FLAGS) -o $(1)-profile~ $(patsubst %-debug.a,%-profile.a,$($(1)_objs:.o=.Po)) $(patsubst %-debug,%-profile,$($(1)_libs)) || exit 1; \
	[ ! -f $(1)-profile ] || mv $(1)-profile $(1)-profile.old; \
	mv $(1)-profile~ $(1)-profile; \
	rm -f $(1)-profile.old

optimize_program_target = $(1)-optimize: $(patsubst %-debug.a,%-optimize.a,$($(1)_objs:.o=.Oo)) $(patsubst %-debug.a,%-optimize.a,$($(1)_deps)); \
	$(CXX) $(CFLAGS) $(OPTIMIZE_FLAGS) $(LINK_FLAGS) -o $(1)-optimize~ $(patsubst %-debug.a,%-optimize.a,$($(1)_objs:.o=.Oo)) $(patsubst %-debug,%-optimize,$($(1)_libs)) || exit 1; \
	[ ! -f $(1)-optimize ] || mv $(1)-optimize $(1)-optimize.old; \
	mv $(1)-optimize~ $(1)-optimize; \
	rm -f $(1)-optimize.old

static_program_target = $(1)-static: $(patsubst %-debug.a,%-optimize.a,$($(1)_objs:.o=.Oo)) $(patsubst %-debug.a,%-optimize.a,$($(1)_deps)); \
	$(CXX) -static $(CFLAGS) $(OPTIMIZE_FLAGS) $(LINK_FLAGS) -o $(1)-static~ $(patsubst %-debug.a,%-optimize.a,$($(1)_objs:.o=.Oo)) $(patsubst %-debug,%-optimize,$($(1)_libs)) || exit 1; \
	[ ! -f $(1)-static ] || mv $(1)-static $(1)-static.old; \
	mv $(1)-static~ $(1)-static; \
	rm -f $(1)-static.old

# Following doesn't work; sent mail to gmake maintainer asking if it should.
#  -- reply was that it doesn't now, but will eventually.
#
# define all_program_targets
# $(call debug_program_target,$1)
# 
# $(call profile_program_target,$1)
# 
# $(call optimize_program_target,$1)
# endef

debug_lib_target = $(1)-debug.a: .make.depend $($(1)_objs:.o=.Do); \
	[ ! -f $(1)-debug.a ] || rm $(1)-debug.a; \
	ar cr $(1)-debug.a $($(1)_objs:.o=.Do)
	
profile_lib_target = $(1)-profile.a: .make.depend $($(1)_objs:.o=.Po); \
	[ ! -f $(1)-profile.a ] || rm $(1)-profile.a; \
	ar cr $(1)-profile.a $($(1)_objs:.o=.Po)
	
optimize_lib_target = $(1)-optimize.a: .make.depend $($(1)_objs:.o=.Oo); \
	[ ! -f $(1)-optimize.a ] || rm $(1)-optimize.a; \
	ar cr $(1)-optimize.a $($(1)_objs:.o=.Oo)

### Find all of the other .mk files we should include
INCDOTMKFILES := $(wildcard */subdir.mk *.mk) 
include $(INCDOTMKFILES)

# BUG: DEPEND_SRCS has a potential drawback/gotcha, as it won't result in
# dependancies being made for generated files, even though they may
# actually depend on some (e.g.) header file.
ifndef DEPEND_SRCS
    DEPEND_SRCS = $(SRCS)
endif

DEPEND_DEPS := Makefile $(DEPEND_SRCS)

### If the user said make depend, then we want to really rebuild the
### dependencies, even if we don't think they need it.

ifeq (depend, $(findstring depend, $(MAKECMDGOALS)))
    DEPEND_DEPS := FORCE_DEPEND
    # The touch/remove for depend target causes it to rebuild the dependencies
    # only once.  Otherwise they get rebuilt multiple times for no reason I can
    # discover.
    FORCE_DEPEND:
	@touch FORCE_DEPEND
endif

# Don't rebuild dependencies just to clean
ifeq (clean, $(findstring clean,$(MAKECMDGOALS)))
    DEPEND_DEPS := 
endif

depend: .make.depend
	@[ ! -f FORCE_DEPEND ] || rm -f FORCE_DEPEND


# The ever infinitely growing list of places to look to find the STL
# include files so that makedepend doesn't complain. These should be
# revisted periodically to see if they are all still needed. We don't
# care if we find the wrong system include files, as we remove them from
# the dependancies list anyway.

ifeq ($(OS), HP-UX)
    STL_INCLUDE := -I/opt/aCC/include -I/opt/aCC -I/opt/aCC/include/iostream 
endif

ifeq ($(OS), Linux)
    STL_INCLUDE := -I/usr/local/include/g++-3 -I/usr/include/linux -I/opt/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.2/include -I/opt/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include -I/usr/include/g++-3 -I/usr/include/g++-2
endif

# V1.33 didn't update .make.depend if none of the dependencies had
# changed; however that results in the dependencies being rebuilt on
# every call to make because the timestamp never gets updated; it
# would appear this was because a bunch of Makefiles had a spurious
# dependancy on .make.depend in the binaries, which would cause them
# to be rebuilt even if there weren't relevant changes.  The other
# makefiles should be fixed.

.make.depend: $(DEPEND_DEPS)
	@echo "Rebuilding dependencies..."
	@touch .make.depend.ZZZ
	@makedepend -w 10 -DDOING_MAKEDEPEND -f .make.depend.ZZZ -o .ZZZ $(CXXFLAGS) $(COMMON_FLAGS) $(STL_INCLUDE) -- $(DEPEND_SRCS) >.make.depend.out 2>&1
	@grep -v /usr/ .make.depend.ZZZ > .make.depend.ZZZ.tmp
	@grep -v /opt/ .make.depend.ZZZ.tmp > .make.depend.ZZZ
	@sed 's/ZZZ/Do/' <.make.depend.ZZZ >>.make.depend.new
	@sed 's/ZZZ/Po/' <.make.depend.ZZZ >>.make.depend.new
	@sed 's/ZZZ/Oo/' <.make.depend.ZZZ >>.make.depend.new
	@sed 's/ZZZ/Fo/' <.make.depend.ZZZ >>.make.depend.new
	@rm -f .make.depend.ZZZ*
	@[ -f .make.depend ] || touch .make.depend
	@if cmp .make.depend .make.depend.new >/dev/null 2>&1; then \
		echo "Dependencies unchanged."; \
	else \
		echo "Dependencies changed."; \
	        cat .make.depend.out; \
	fi 
	[ ! -f .make.depend ] || rm -f .make.depend
	@mv .make.depend.new .make.depend
	@rm .make.depend.out

### Standard clean targets.

clean::
	-rm -f .make.depend* *\~ FORCE_DEPEND gmon.out 2>/dev/null
	-rm -f *.?o */*.?o
	-rm -f core


### All of the magic ways to convert sources to objects.

%.Do : %.C
	$(CXX) -c $(CXXFLAGS) $($(notdir $*)_flags) $(DEBUG_FLAGS) $(CPPFLAGS) $< -o $@

%.Po : %.C
	$(CXX) -c $(CXXFLAGS) $($(notdir $*)_flags) $(PROFILE_FLAGS) $(CPPFLAGS) $< -o $@

%.Oo : %.C
	$(CXX) -c $(CXXFLAGS) $($(notdir $*)_flags) $(OPTIMIZE_FLAGS) $(CPPFLAGS) $< -o $@

# for just C also.

%.Do : %.c 
	$(CXX) -c $(CXXFLAGS) $($(notdir $*)_flags) $(DEBUG_FLAGS) $(CPPFLAGS) $< -o $@

%.Po : %.c 
	$(CXX) -c $(CXXFLAGS) $($(notdir $*)_flags) $(PROFILE_FLAGS) $(CPPFLAGS) $< -o $@

%.Oo : %.c 
	$(CXX) -c $(CXXFLAGS) $($(notdir $*)_flags) $(OPTIMIZE_FLAGS) $(CPPFLAGS) $< -o $@

# if .make.depend exists, include it
-include .make.depend
