#!@PERL_PATH@ -w
# -*- Perl -*-
#
#  (c) Copyright 2004-2008, Hewlett-Packard Development Company, LP
#
#  See the file named COPYING for license details
=pod

=head1 NAME

deptool - a program for helping with the software development process

=cut

use strict;

use Carp;
use Cwd;
use Digest::SHA1 'sha1_hex';
use English;
use File::Compare;
use File::Copy;
use File::Path;
use File::Find;
use File::stat;
use FileHandle;
use Getopt::Long;
use File::Basename;
use POSIX 'ceil';
use Pod::Usage;

# TODO: pull should walk in the current directory before walking in the
# dependent ones since it may need additional dependencies, and/or they
# may have changed.  Test case is revision in tla that switched the
# dependencies around.

# TODO: builds have to be serialized, but tests should be runnable in parallel.

# TODO: check for make file left overs in source directory (these should only
# be in build, or debug, or etc. directories). Jay at least seems to futz up
# and make crap in src every so often those breaking depbuild (or at least
# misleading it as to what has been created and what should be recreated).

# TODO: think about how to check for rebuild after make clean
# TODO: allow for commits without testing (with an option)
# TODO: separate between short and long tests

sub usage {
    pod2usage(-exitval => 'NOEXIT', -verbose => 0);
    confess @_ if @_ > 0;
    exit(0);
}

=pod

=head1 SYNOPSIS

 % deptool <command> [-y (auto-yes to prompts)] [--man] [options] [args]
   init [--server=<hostname>] [branch-prefix...]
   checkout <branch-substring...> # checkout branch and dependencies
   pull # pull branch and dependencies
   build [-t (and test)] [-d (debug build)] [-b (optimize build)]
   commit # commit branch after dependencies
   publish # publish branch and dependencies
   cmake # run cmake with special options for current branch
   pin <revision> # pin branch at a particular revision
   code-review <revision...> # code-review a revision
   help [commands|options|environment|command-name] # get help

=head1 OVERVIEW

The deptool command is designed to assist with the software
development process.  In particular, it has support for getting the
version controlled copy of software via the monotone version control
system, building, committing, and publishing said software after
running appropriate tests, and easing code reviews of a collection of
changes.  Since software often has multiple dependencies that all need
to be built and updated, deptool is able to handle a related set of
software via version control dependencies specified as part of the
source code.  Since you may want to build software with multiple
options, deptool is able to handle additional build-type directories
which will automatically enable configuration with additional
arguments.  Deptool keeps stamp files so that it can avoid rebuilding
and testing a package which has dependencies from two separate places.

In general, use of deptool consists of the following steps:

    % deptool init # initial environment preparation
    % deptool checkout branch-substring... # checkout sources
    % cd ~/projects/project-name
    % deptool build # build project-name and its dependencies
    # edit the source code
    % deptool commit # optional; if it's not yet ready to be public
    % deptool publish # make changes visible to other people

To set up the environment, and make it easier to move between the
source and build directories, you probably want to put something like
the following in your shell startup files; unfortunately the cdopt and
cddebug bits only work under sh-based shells right now.

    DEPTOOL=`(echo $HOME/build/opt*/bin/deptool) 2>/dev/null | awk '{print $1}'`
    eval `$DEPTOOL getenv for-sh`

    s () { eval `$DEPTOOL cdsrc $PWD` }
    b () { eval `$DEPTOOL cdopt $PWD "$@"` }
    d () { eval `$DEPTOOL cddebug $PWD "$@"` }


Occasionally if something has been incorrectly committed, or you want
to force reconfiguration, you may need commands like:

    % deptool pin <revision> # work around bad published revision
    % deptool cmake clean # clean out cmake config files
    % deptool cmake # rebuild the cmake configuration
    % make -j $MAKE_PARALLELISM # rebuild in parallel using the deptool env

If you need to add a dependency, then you need to edit the file
.version_control_deps so that it lists the dependencies.  The file
simply contains one line that lists branch substrings that should be
built and installed before the current source directory is built.  If
you want special builds, then you can list them as
'I<dependency>;I<build-type>' (without the '').  This input has the
same effect as creating a dependency where you run b I<build-type> and
then build in that directory.

=cut

my $auto_yes_to_prompts = 0;
my $quiet = 0;
my $print_manpage = 0;
my $noconfig = 0;

Getopt::Long::Configure(qw/pass_through no_auto_abbrev/);
GetOptions("y!" => \$auto_yes_to_prompts,
           "quiet!" => \$quiet, 
	   "noconfig!" => \$noconfig,
           "projects=s" => \$Cache::projects,
           "build-root=s" => \$Cache::build_root,
           "operating-system=s" => \$Cache::operating_system,
           "uname-m=s" => \$Cache::uname_m,
           "build-debug=s" => \$Cache::build_debug,
           "build-opt=s" => \$Cache::build_optimize,
	   "man!" => \$print_manpage);

=pod

=head1 OPTIONS

=over 4

=item -y 

Automatically answer 'yes' to all of the prompts that are provided if
there is a sane default answer.

=item --quiet

Print out less output by default; the output from the commands being
run will still be printed out.

=item --projects=<path>

Specify the default projects directory.  Normally this would come from
the PROJECTS environment variable, which defaults to ~/projects.

=item --build-root=<path>

Specify the default root build directory.  Normally this would come from
the BUILD_ROOT environment variable, which defaults to ~/build.

=item --operating-system=<string>

Specify the operating system's name.  Normally this would be specified
in the OS environment variable, which defaults to various strings depending
on the inferred operating system, e.g. debian-etch, or rhel5.

=item --uname-m=<string>

Specify the hardware machine type.  Normally this would be specified
by the UNAME_M environment variable, which defaults to the output from
uname -m.

=item --build-debug=<path>

Specify the debugging build directory.  Normally this would be
specified by the BUILD_DEBUG environment variable, which defaults to
$BUILD_ROOT/dbg-$OS-$UNAME_M, or $BUILD_ROOT/debug if that directory
exists.

=item --build-opt=<path>

Specify the optimize build directory.  Normally this would be
specified by the BUILD_OPT environment variable, which defaults to
$BUILD_ROOT/opt-$OS-$UNAME_M, or $BUILD_ROOT/optimize if that
directory exists.

=item --man

Print out the complete manual page.

=back

=cut

Getopt::Long::Configure(qw/no_pass_through auto_abbrev/);

help("all") if $print_manpage;

usage("Missing argument") if @ARGV == 0;

readConfigFile();

my %commands = ('checkout' => \&depCheckout,
		'co' => \&depCheckout,
                'pull' => \&depPull,
                'build' => \&depBuild,
#		'clear' => \&depClear,
                'commit' => \&depCommit,
                'publish' => \&depPublish,
                # below commands don't run in all dep dirs.
                'init' => \&depInit,
                'cmake' => \&runCMake,
                'pin' => \&setPin,
                'code-review' => \&codeReview,
                'mtnpull' => sub { mtnOp("pull"); },
                'mtnpush' => sub { mtnOp("push"); },
                'mtnsync' => sub { mtnOp("sync"); },
                'mtnserve' => \&mtnServe, 
                'getenv' => \&getEnv,
                'cdsrc' => \&cdSrc,
                'cdopt' => sub { cdBuild('opt'); },
                'cddebug' => sub { cdBuild('debug'); },
		# get usage without error message
		'-h' => \&usage,
		'--help' => \&usage,
		'help' => sub { help(@ARGV); },
);

=pod

=head1 COMMANDS

Further details on all commands can be found by running C<deptool
help> I<command>

=over 4

=item init [I<--server=hostname>] [I<branch-prefix>]

Initialize the system, this will create the appropriate version
control files, and will pull the initial database(s). 

=item checkout I<branch-substring>

Select a particular branch by using branch-substring.  Checkout that
branch and all of its dependencies into $PROJECTS.  You can use co as
a shorter alias for this command.

=item pull 

Select the current branch based on the current directory.  Pull the
current branch and all it's dependencies from the server specified in
the _MTN directory.

=item build [I<-t>] [I<-d>] [I<-b>]

Build and install the current branch after building and installing its
dependencies.  Select the type of build (debug or optimized) based on
the current directory or the options.  

=item commit

Commit the current branch after committing its dependencies.  If there
are unknown files, prompt for them to be either added or ignored.  If
there are changes, perform a build and test before performing the
commit.

=item publish

Perform the full publishing steps; first run a commit, then build and
test, next pull and update.  If no changes were made, synchronize the
updates to the central server.  Alternately, restart the loop at the
build and test stage.

=item cmake [I<--clean> | I<clean>]

Run the cmake configuration command, or clean out the cmake
configuration files.  See help cmake for details on how cmake is
run.

=item pin I<revision>

Pin the current source directory to a particular revision after
updating the current source directory to that revision.

=item code-review I<revision>...

Perform a code review of the selected revisions.  This will treat the
collection of revisions as if they were a single change.  Currently it
works poorly if there are renames in the changes.

=item mtnpull

Run the mtn pull operation with the appropriate options based on the
current directory.

=item mtnpush

Run the mtn push operation with the appropriate options based on the
current directory.

=item mtnsync

Run the mtn sync operation with the appropriate options based on the
current directory.

=item mtnserve

Start up a monotone server based on the database for the current
directory.

=item getenv I<variable> I<for-{sh,csh}>

Print the selected environment information.  If a variable is
specified, then just that variable will be printed.  If for-sh or
for-csh is specified, then all environment variables will be printed
using the syntax of the specified shell.

=item cdsrc I<dir>

Print out the command to cd to the source directory for the specified
directory.

=item cdopt I<dir> [I<build-type>]

Print out the command to cd to the optimized build directory for the
specified directory and optional build type.  Currently does not work
for csh-style shells.

=item cddebug I<dir> [I<build-type>]

Same as cdopt, except for the debug build directory.

=back

=head1 COMMAND DETAILS

=cut

my $command = shift @ARGV;
my $monotone_dir = "$ENV{HOME}/.monotone";
my $fn = $commands{$command};

usage("Unrecognized command '$command'") unless defined $fn;
$|=1;

# handle case where start dir is a symlink
aliasChdir($ENV{PWD}) if defined $ENV{PWD};
&$fn;

sub help {
    my ($what) = @_;
    $what ||= 'all';
    if ($what eq 'all') {
	# Might be able to get rid of the 'user contributed perl doc'
	# stuff in the man page title by invoking perldoc ourselves.
	pod2usage(-verbose => 2, -exitval => 0);
    } elsif ($what eq 'commands') {
	pod2usage(-verbose => 99, -sections => 'COMMANDS', -exitval => 0);
    } elsif (defined $commands{$what}) {
	pod2usage(-verbose => 99, 
		  -sections => "COMMAND DETAILS/^$what( .*)?\$", 
		  -exitval => 0);
    } else {
	usage("Unknown option to help '$what'");
    }

    exit(0);
}

##### Dependency Init

=pod

=head2 init [I<branch-prefix>...]

The init command will initialize the default setup for the monotone
version control system.  It will also populate the initial database
for checkouts, in particular, the one that would contain Lintel since
deptool is in Lintel.  By default it assumes that usi.hpl.hp.com is
the central version control server.  It will use ssd as the default
branch prefix.  If you do not have the environment variables set up by
using the getenv command, deptool will ask a number of questions about
where the files should be placed.  It is usually safe to run the init
command with the -y option so that these questions will be
automatically answered.  

After you have run init, you will have a key file.  To be able to sync
to a particular server, you need to send the public key to the
monotone administrator for that server.  For HPL, the administrator of
usi.hpl.hp.com is anderse@hpl.hp.com.

B<Warning:> If you already have a key set up on one machine, you
should just copy your keys directory to the new machine rather than
creating a new key.  Monotone can get confused by multiple keys with
the same email address.

=cut

sub depInit {
    checkForMtn();

    my $server = "usi.hpl.hp.com";
    my $email;
    my $result = GetOptions("server=s" => \$server);
    usage("Unknown error") unless $result;
    my @branch_prefixes = @ARGV;
    if (@branch_prefixes == 0) {
        print "Assuming default branch prefix ssd\n";
        @branch_prefixes = ("ssd");
    }

    initMtnDir();
    initMtnKeysRc();

    initDbs($server, \@branch_prefixes);
}

sub checkForMtn {
    my @paths = split(/:/, $ENV{PATH});
    foreach my $path (@paths) {
        return if -x "$path/mtn";
    }
    die "Unable to find mtn binary in path; you should repair this.
Usually yum install monotone or apt-get install monotone will work.
http://usi.hpl.hp.com/twiki/pub/USI/MonotoneVersionControl/mtn-static
is a static linux binary, alternately, you can get something from
the monotone web site: http://www.monotone.ca/";
}

sub initMtnDir {
    if (! -d $monotone_dir) {
        userPrompt("Create monotone directory $monotone_dir");
        mkdir($monotone_dir, 0755) or die "Unable to mkdir $monotone_dir: $!";
    }
}

sub initMtnKeysRc {
    if (! -d "$monotone_dir/keys") {
        print <<EOF;

The key will be generated with an empty password.  You can change it
by running mtn chkeypass or mtn passphrase depending on your monotone
version.

WARNING: if you already have a monotone key, you should ctrl-c now, and copy
WARNING: your key file over.  Monotone deals poorly with multiple keys with
WARNING: the same e-mail address.
EOF
        
        print "Enter e-mail address for identifying monotone key: ";
        my $email = <STDIN>;
        chomp $email;
        die "?? $email" unless $email =~ /^\S+\@\w+\.\w+$/o;

        runCommand("yes default-password | mtn genkey $email");

        print <<"END";
Key generated with password 'default-password'; can be changed with
mtn chkeypass or mtn passphrase depending on your monotone version
END

        chmod(0700, "$monotone_dir/keys");
        if (-f "$monotone_dir/monotonerc") {
            print <<"EOF";
You probably want to add:
function get_passphrase(keypair_id)
  return "default-password"
end
To your $monotone_dir/monotonerc file
EOF
        } else {
            userPrompt("Create default monotonerc?");
            my $mtnrc = new FileHandle(">$monotone_dir/monotonerc")
                or die "can't write $monotone_dir/monotonerc: $!";
            print $mtnrc <<"EOF";
-- Change with mtn chkeypass or mtn passphrase, then change here.
function get_passphrase(keypair_id)
  return "default-password"
end

-- Next three are for letting you run your own server 
function get_netsync_read_permitted (collection, identity)
  return true
end

function get_netsync_write_permitted (identity)
  if (identity == "$email") then return true end
  return false
end

function get_netsync_anonymous_read_permitted (collection)
  return true
end

-- performance optimization
function get_vcache_size()
  return 512*1024*1024
end
EOF
            chmod(0700, "$monotone_dir/monotonerc");
        }
    }
}

sub initDbs {
    my($server, $branch_prefixes) = @_;

    foreach my $branch_prefix (@$branch_prefixes) {
        my $db = $branch_prefix;
        $db =~ s/\W.*$//o;
        die "Invalid branch prefix $branch_prefix, should start with normal chars"
            if $db eq '';
        unless (-f "$monotone_dir/${db}.db") {
            userPrompt("create local repository $monotone_dir/${db}.db");
            runCommand("mtn -d $monotone_dir/${db}.db db init");
        }

        userPrompt("pull $branch_prefix* from $server (can take a while)");
        my $qm = quotemeta $branch_prefix;
        runCommand("mtn -d $monotone_dir/${db}.db pull $server $qm\\*");
    }
}

##### Dependency Checkout

=pod

=head2 checkout I<branch-substring>...

The checkout command, which can be abbreviated as co, checks out a
branch and its dependencies.  It will find the appropriate branch by
selecting from all the branches in the databases found as
~/.monotone/*.db.  It will choose the directory name based on the
branch name after stripping out the initial uniquifier.  This is based
on the assumption that branches will be named as
I<uniquifier>/I<branch-name>/I<sub-branch>.  Deptool will
automatically select the branch that matches with the least length so
it will ignore sub-branches that may be present.  For example, if you
ran checkout Data, it would select the ssd.hpl.hp.com/DataSeries
branch and put the checkout in ~/projects/DataSeries (by default,
changeable by setting $PROJECTS).  It would then checkout Lintel since
Lintel is a dependency for DataSeries.

If multiple branches match and they do not share a common prefix,
deptool will abort the checkout.

=head2 co

See help checkout

=cut

sub depCheckout {
    my $result = GetOptions("y!" => \$auto_yes_to_prompts);
    usage("Unknown error") unless $result;

    usage("No branch-substrings specified") unless @ARGV > 0;

    my $projects = projects();
    
    my @dbs = glob("$monotone_dir/*.db");
    die "No *.db files in $monotone_dir; did you run $0 init?"
        unless @dbs > 0;

    my @branches;
    my %branch_to_db;
    foreach my $db (@dbs) {
        my $tmp = new FileHandle("mtn -d $db list branches |");
        my @tmp = <$tmp>;
        close($tmp);
        grep(chomp, @tmp);
        push(@branches, @tmp);
        map { 
            warn "duplicate db ($db, $branch_to_db{$_}) for branch $_
will use latter."
                if defined $branch_to_db{$_};
            $branch_to_db{$_} = $db 
            } @tmp;
    }

    my @branch_regexes = (@ARGV);
    my %did_regex;
    while (@branch_regexes > 0) {
        my $branch_regex = shift @branch_regexes;
        next if $did_regex{$branch_regex};
        $did_regex{$branch_regex} = 1;

	$branch_regex =~ s/;\w+//o;
	$branch_regex = "/$branch_regex" unless $branch_regex =~ m!/!o;
        my @possibles = grep(m/$branch_regex/, @branches);
        die "No branches found matching $branch_regex"
            unless @possibles > 0;
        @possibles = sort { length $a <=> length $b } @possibles;
        
        my $branch = shift @possibles;
        foreach $_ (@possibles) {
            die "multiple non-prefixed matches for $branch_regex:
$branch $_\nYou need to provide more specificity in the .version_control_deps file\n " 
		unless /^$branch/;
        }
        
        my $db = $branch_to_db{$branch};
        my $dir = $branch;
        $dir =~ s!^\w+(\.\w+)*/!!o; # strip uniqueifier we put on
        my $path = "$projects/$dir";
        print << "END";

Selected branch $branch
From database $db
Inferred projects directory $dir
Inferred full path $path
END

        if (-d "$path/_MTN") {
            print "Found $path/_MTN; skipping redundant checkout.\n";
        } else {
	    die "$path already exists; mtn checkout would fail"
		if -d $path;
            userPrompt("continue even though you have a / in the directory")
                if $dir =~ m!/!o;
        
            runCommand("mtn -d $db co -b $branch $path");
        }
        my @vcdeps = readVCDeps("$path/.version_control_deps");
        if (@vcdeps > 0) {
            print "Adding VC dependencies: ", join(" ", @vcdeps), "\n";
            push(@branch_regexes, @vcdeps);
        }
    }        
}

##### Dependency build

=pod

=head2 build [I<-t>] [I<-d>] [I<-b>]

This command will build the current project directory after building
and installing all of the dependencies.  The type of build is
determined by the current directory and the options.  If either -d or
-b are specified, then we perform a debug or an optimized build
respectively.  If we are in the projects directory or an optimized
build directory, we perform an optimized build.  If we are in a debug
build directory, we perform a debug build.  If -t is specified, tests
will be run in addition to building and installing each of the packages.

If a directory hasn't been configured, then the deptool cmake command
will be automatically run to configure the package before it is built.

=cut

sub depBuild {
    my %options = @_;
    $options{tests} ||= 0;

    my $cwd = aliasGetCwd();
    my $debug = buildDebug();
    if ($cwd =~ /^$debug/o) {
        $options{mode} = 'debug';
    } else {
        $options{mode} = 'optimize';
    }

    my $ret = GetOptions("y!" => \$auto_yes_to_prompts,
                         "t|tests!" => \$options{tests},
                         "o|optimize" => sub { $options{mode} = 'optimize' },
                         "d|debug" => sub { $options{mode} = 'debug' });
    usage("unknown option to build") unless $ret;

    $options{builddir} = $options{mode} eq 'debug' ? buildDebug() : buildOpt();
    $options{projects} = projects();

    depWalk(sub { depBuildOne(\%options, @_) }, 1);
}

sub depBuildOne {
    my ($options, $build_type) = @_;

    my $src = aliasGetCwd();
    die "? '$src' '$options->{projects}'" 
        unless $src =~ /^$options->{projects}/o;
    my($project, $subdir, $tmp) = divideDir($src);
    my $build = "$options->{builddir}/$project";
    $build .= "-$build_type" if $build_type ne '';
    print "Building in $build\n" unless $quiet;
    unless(-d $build) {
        mkpath($build);
    }
    aliasChdir($build);
    depBuildCheckOld($src, $build, $options);
    depBuildMake($src, $build, $options);
    depBuildTest($build, $options);
    depBuildInstall($build, $options)
}

sub depBuildCheckOld {
    my($src, $build, $options) = @_;

    print "depbuild: Checking if any files in $src\n";
    print "depbuild: are out of date w.r.t $build\n";
    if (! -f ".deptool.build_stamp") {
        print "depbuild:  missing .deptool.build_stamp, build definitely out of date\n";
        return;
    }
    if ($options->{did_install}) {
        print "depbuild:  did an install in another directory, so we are out of date\n";
        unlink(".deptool.build_stamp") or die "?";
        return;
    }
    my @old_files = depBuildFindOld($src);
    if (@old_files > 0) {
        print "\n" x 5;
        print join("\n", @old_files, '');
        print "depbuild: out of date w.r.t above files.";
        unlink(".deptool.build_stamp") or die "?";
        return;
    }
    print "depbuild:  up to date in $build\n";
}

sub depBuildFindOld {
    my ($src) = @_; 
    die "??" unless defined $src;

    my $ref_stat = stat(".deptool.build_stamp")
        or die "Unable to stat .deptool.build_stamp: $!";
    my @newer;
    find(sub { return unless -f $_;
               return if $File::Find::name =~ m!^$src/_MTN!;
               my $stat = stat($_) or die "can't stat $_: $!";
               push(@newer, $File::Find::name)
                   if $stat->mtime() > $ref_stat->mtime(); }, $src);
               
    return @newer;
}

sub depBuildMake {
    my($src, $build, $options) = @_;

    if (-f ".deptool.build_stamp") {
        print "depbuild: $build already has current build\n";
        return;
    }
    if (! -f "Makefile" || ! -d "CMakeFiles" || ! -f "CMakeCache.txt") {
        local @ARGV = ();
        print "depbuild: creating makefile in $build\n";
        runCMakeConfig();
    }

    print "depbuild: building...\n";
    my $make_parallelism = makeParallelism();
    runCommand("make", "-j", $make_parallelism);
    stamp("build");
}

sub depBuildTest {
    my($build, $options) = @_;
    return unless $options->{tests};

    if (stampUpToDate("test")) {
        print "depbuild: Tests are up to date in $build\n";
    } else {
        print "depbuild: Running tests in $build...\n";
        runCommand("make","test");
        stamp("test");
    } 
}

sub stampUpToDate {
    my($which) = @_;

    return 0 unless -f ".deptool.${which}_stamp";
    my $build_stat = stat(".deptool.build_stamp")
        or die "Unable to stat .deptool.build_stamp: $!";
    my $which_stat = stat(".deptool.${which}_stamp")
        or die "Unable to stat .deptool.${which}_stamp: $!";
    return $which_stat->mtime() > $build_stat->mtime();
}

sub stamp {
    my($which) = @_;
    
    my $filename = ".deptool.${which}_stamp";
    while(1) {
        my $fh = new FileHandle("+>>$filename")
            or die "Can't open $filename for append: $!";
        close($fh);
        utime undef, undef, $filename;
        last if $which eq 'build' || stampUpToDate($which);
        print "deptool: sleep(1) to make sure ${which} timestamp is more recent than build\n";
        sleep(1);
    }
}

sub depBuildInstall {
    my($build, $options) = @_;

    if (stampUpToDate("install","build")) {
        print "depbuild: Install up to date in $build\n";
    } else {
        runCommand("make","install");
        stamp("install");
        $options->{did_install} = 1;
    }
}

## ##### Dependency clear
## 
## =pod
## 
## =head2 clear [I<-b|--build>] [I<-d|--debug>] I<project>...
## 
## This command will delete the B<source> directories for project and its
## dependencies.  If -b is specified, the build (optimized) directory
## will also be deleted.  If -d is specified, the debug directory will be
## deleted.
## 
## =cut
## 
## sub depClear {
##     my %options = @_;
## 
##     my $projects = projects();
##     my @dirs;
##     $options{build} = 0;
##     $options{debug} = 0;
##     my $ret = GetOptions("y!" => \$auto_yes_to_prompts,
## 			 "quiet!" => \$quiet,
## 			 "b|build!" => \$options{build},
## 			 "d|debug!" => \$options{debug});
## 
##     usage("unknown option to clear") unless $ret;
##     my @projects = @ARGV;
## 
##     my $build_debug = buildDebug();
##     my $build_opt = buildOpt();
##     foreach (@projects) {
## 	aliasChdir("$projects/$_");
## 	depWalk(sub{ my $wd = aliasGetCwd(); 
## 		     # be paranoid, we're going to delete these directories
## 		     die "internal" unless $wd =~ m!^$projects/!o;
## 		     push (@dirs, $wd); });
##     }
## 
##     push(@dirs, buildDebug())
## 	if $options{debug};
##     push(@dirs, buildOpt()) 
## 	if $options{build};
## 
##     foreach my $dir (@{$options{dirs}}) {
## 	if (-d $dir) {
## 	    userPrompt("delete $dir");
## 	    rmtree($dir, 0, 1);
## 	    die "Unable to remove directory $dir"
## 		if -d $dir;
## 	}
##     }
## }

##### Set pin

=pod

=head2 pin I<revision>

Occasionally someone will publish an update to a project that works
for that project, but breaks a project that depends on it.  If they
didn't test that project, then builds will fail until the software is
repaired.  In order to work around this problem, you can pin the
revision back to the one that used to work.  This command only works
in a source directory.  If the current source directory isn't at the
specified revision, then it will update to the specified revision.
The pin will remain until the head revision for the project changes,
as the assumption is that when the head revision changes it has fixed
the bug.

=cut

sub setPin {
    die "Have unknown files; setpin is disallowed"
        if depCommitHaveUnknown();
    die "Have changes; setpin is disallowed"
        if depCommitHaveChanges();
    my @heads = getCurHeads();
    die "Have multiple heads; setpin is disallowed"
        unless @heads == 1;
    my($revision) = @ARGV;

    if (defined $revision) {
        runCommand("mtn","update","-r",$revision);
    }

    $revision = getCurRevision()
        unless defined $revision;
    
    my $filename = depPinFilename();
    my $fh = new FileHandle ">>$filename"
        or die "Unable to open $filename for append: $!";
    print $fh "$heads[0] $revision\n";
    print "Pinning to $revision so long as head remains at $heads[0]\n";
    close($fh);
}

##### Dependency pull

=pod

=head2 pull

If you want to update your local repositories and projects, but aren't
yet ready to make your changes available or just want changes other
people have made, then pull is the command you want to use.  Pull will
walk all of the directories dependent on your current directory and
will pull data from the central server and then update the local
directory.  If you happen to have outstanding changes, pull will
perform a commit before doing the update so that you wouldn't
accidentally destroy your current changes.

=cut

sub depPull {
    my %options;
    depWalk(sub { depPullOne(\%options); });
}

### sets $options->{made_changes} if we made changes.

sub depPullOne {
    my($options) = @_;

    depCommitOne();
    mtnOp("pull");
    depPullMerge();
    depPullUpdate($options);
}

sub depPullMerge {
    while(1) {
        my $fh = new FileHandle "mtn automate heads |";
        my @heads = getCurHeads();
        last if @heads == 1;
        my $cwd = aliasGetCwd();
        print "\n" x 5, "You have multiple heads in $cwd.";
        userPrompt("merge the heads");
        runCommand("mtn","merge");
    }
}

sub depPullUpdate {
    my($options) = @_;

    my $cwd = aliasGetCwd();
    my $cur_rev = getCurRevision();
    my $deppin_filename = depPinFilename();
    if (-f $deppin_filename) {
        my @heads = getCurHeads();
        die "??" unless @heads == 1;
        
        if (foundPin($cur_rev, $heads[0])) {
	    print << "END";
****
  You are currently pinned to revision $cur_rev
  The head revision has not changed, so the pin remains.
  To remove the pin, edit $deppin_filename
****
END
            return;
        } elsif (hadPin($cur_rev)) {
            print <<"END";
****
You would be pinned to $cur_rev, but the head
has been updated.  To reset the pin:
cd $cwd; deptool pin $cur_rev
****
END
            # skip prompting, will do so for the update.
        }
    }
    while(1) {
        my $cur_rev = getCurRevision();
        my @heads = getCurHeads();
        die "??" unless @heads == 1;
        last if $cur_rev eq $heads[0];
        print <<"END";
You current checkout is not up to date in $cwd.
$cur_rev != $heads[0]
END
        userPrompt("update to the current revision");
        runCommand("mtn","update");
        $options->{made_changes} = 1;
    }
}

sub foundPin {
    my($rev, $head) = @_;

    my $filename = depPinFilename();
    return 0 unless -r $filename;
    my $fh = new FileHandle($filename)
        or die "Can't open $filename for read: $!";
    while(<$fh>) {
        return 1 if /^$head $rev$/;
    }
    return 0;
}

sub hadPin {
    my($rev) = @_;

    my $filename = depPinFilename();
    return 0 unless -r $filename;
    my $fh = new FileHandle($filename)
        or die "Can't open $filename for read: $!";
    while(<$fh>) {
        return 1 if /$rev$/;
    }
    return 0;
}

sub getCurHeads {
    my($fh) = new FileHandle("mtn automate heads |")
        or die "Unable to fork: $!";
    my @heads = <$fh>;
    close($fh);
    die "??" unless @heads > 0;
    grep(chomp, @heads);
    return @heads;
}

sub getCurRevision {
    my($fh) = new FileHandle("mtn automate get_base_revision_id |")
        or die "Unable to fork: $!";

    local $_ = <$fh>;
    die "??" unless $_ =~ /^[a-fA-F0-9]{40}$/o;
    chomp;
    close($fh);
    return $_;
}

sub depPinFilename {
    return "$ENV{HOME}/.monotone/deptool-version-pins";
}

##### Dependency commit

=pod

=head2 commit

If you have a set of changes that are sufficiently complete to pass
all the tests, but not yet ready for publishing, then you can run
deptool commit in order to commit all of the changes you have made as
well as any changes in dependent projects.  Commit will first run all
of the tests to verify that the changes are internally consistent.

=cut

### depcommit -- commit all the files in the dependency tree;
### generates the variable depcommit_made_changes as a side effect

sub depCommit {
    my %options;

    depWalk(\&depCommitOne);
}

sub depCommitOne {
    my $cwd = aliasGetCwd();

    die "depcommit: ERROR missing _MTN directory in $cwd"
        unless -d "_MTN";
    depCommitUnknown();
    depCommitDoCommit();
}

sub ignoresFileName() {
    return "$ENV{HOME}/.monotone/deptool-commit-ignores";
}

sub depCommitUnknown { 
    my $cwd = aliasGetCwd();
    return unless depCommitHaveUnknown();
    my @unknown = depCommitGetUnknown();
    while(1) {
        print "You have un-added files in $cwd:\n";
        print @unknown;
        print "\nDo you want to ignore or add them [no-default]?";
        $_ = <STDIN>; 
        chomp;
        if ($_ eq 'ignore') {
            my $sha1 = sha1_hex(join('',@unknown));
            my $ignores_name = ignoresFileName();
            my $fh = new FileHandle ">>$ignores_name"
                or die "Can't open $ignores_name: $!";
            print $fh "$cwd $sha1\n";
            close($fh);
            return;
        } elsif ($_ eq 'add') {
            print "Adding files...\n";
            runCommand("mtn","add","--unknown");
            return;
        } else {
            print "Expected 'ignore' or 'add', not '$_'; try again\n";
        }
    }
}

sub depCommitHaveUnknown {
    my @unknown = depCommitGetUnknown();

    return 0 if @unknown == 0;
    my $fh = new FileHandle ignoresFileName();
    if ($fh) {
        my $cwd = aliasGetCwd();
        my $sha1 = sha1_hex(join('', @unknown));
        while(<$fh>) {
            return 0 if $_ eq "$cwd $sha1\n";
        }
    }

    return 1;
}

sub depCommitGetUnknown {
    my $fh = new FileHandle "mtn list unknown |"
        or die "bad fork mtn: $!";
    my @unknown = <$fh>;
    close($fh);
    die "?? mtn" if $?;
    
    return @unknown;
}

sub depCommitHaveChanges {
    my $fh = new FileHandle "mtn diff |"
        or die "fork fail: $!";
    $_ = <$fh>;
    return 1 unless /^\#\s*$/o;
    $_ = <$fh>;
    return 1 unless /^\# no changes\s*$/o;
    $_ = <$fh>;
    return 1 unless /^\#\s*$/o;
    $_ = <$fh>;
    return 1 if defined $_;
    return 0;
}
    
sub depCommitDoCommit {
    my $cwd = aliasGetCwd();
    my $first_time = 1;
    while(1) {
        if (!depCommitHaveChanges()) {
            print "depcommit: no changes in $cwd\n"
                if $first_time;
            return;
        }
        $auto_yes_to_prompts = 0 unless $first_time;
        $first_time = 0;
        print "depcommit: you have uncommitted differences in $cwd
depcommit: will show differences after successful test\n";
        userPrompt("build and test");
        depBuild('tests' => 1);
        print "\n" x 20;
        aliasChdir($cwd);
        runCommand("mtn","diff");
        print "\ndepcommit: You have uncommitted differences (shown above) in $cwd\n";
        userPrompt("commit changes");
        eval { runCommand("mtn","commit"); };
        if ($@) {
            die "$@" if $@ !~ /mtn commit.*failed/o;
            warn "$@"; # redundant?
        }
    }
}

##### runCMake

=pod

=head2 cmake

This command has to be run in either the build or debug directory.  In
the build directory, it will set the install prefix to $BUILD_OPT and
the cmake build type to RelWithDebInfo.  In the debug directory, it
will set the install prefix to $BUILD_DEBUG and the cmake build type
to Debug.  If you are in a sub-type build directory (see cdopt), then
the deptool cmake command will automatically add
-DBUILD_SUBDIR=I<sub-type> to the cmake instantiation so that the
configuration can take into effect the sub-type.

=cut

sub runCMake {
    my $clean = 0;
    Getopt::Long::Configure('pass_through');
    my $result = GetOptions("clean!" => \$clean);
    usage("Unknown argument to runCMake") unless $result;

    if ($clean) {
	usage("unexpected extra arguments") unless @ARGV == 0;
    } elsif (defined $ARGV[0] && $ARGV[0] eq 'clean') {
	usage("unexpected extra arguments") unless @ARGV == 1;
        runCMakeClean();
    } else {
        runCMakeConfig(@ARGV);
    }
}

sub runCMakeClean {
    my $cwd = aliasGetCwd();
    my $projects = projects();
    my $debug = buildDebug();
    my $opt = buildOpt();

    die "Will not clean unless under projects, debug or optimize dir"
        unless $cwd =~ m!^(($projects)|($debug)|($opt))/!o;
    print "Cleaning cmake files out of $cwd\n"
        unless $quiet;
    my @files; 
    my @dirs;
    find(sub { push(@files, $File::Find::name) if /^CMakeCache.txt$/o
                   || /^Makefile$/o;
               push(@dirs, $File::Find::name) if /^CMakeFiles$/o; },
         $cwd);
    unlink(@files) == scalar @files
        or die "Unable to unlink one of @files: $!";
    rmtree(\@dirs);
    map { die "unable to delete $_" if -d $_ } @dirs;
    return 0;
}

sub runCMakeConfig {
    my @extra_args = @_;

    my $cwd = aliasGetCwd();
    my ($src, $build_subdir) = srcDir();
    my $debug = buildDebug();
    my $opt = buildOpt();

    die "Unable to find expected _MTN directory in $src"
        unless -d "$src/_MTN";

    my @cmakecmd = ('cmake');
    if ($cwd =~ /^$debug/o) {
        push(@cmakecmd, "-D", "CMAKE_INSTALL_PREFIX=$debug", "-D",
             "CMAKE_BUILD_TYPE=Debug");
    } elsif ($cwd =~ /^$opt/o) {
        push(@cmakecmd, "-D", "CMAKE_INSTALL_PREFIX=$opt", "-D",
             "CMAKE_BUILD_TYPE=RelWithDebInfo");
    } else {
        die "Not under optimize or debug directory; aborting";
    }

    if (defined $build_subdir) {
        push(@cmakecmd, "-D", "BUILD_SUBDIR=$build_subdir");
    }
    push(@cmakecmd, @extra_args, $src);
    runCommand(@cmakecmd);
}

##### Monotone operations

=pod

=head2 mtnpull

Run the appropriate mtn pull command for the current directory.  The
command will automatically use the right database and branch based on
the current directory, and can be run in both the source directory and
the build directory.  Does not update the current directory, and does
not run for dependencies.

=head2 mtnpush

Run the appropriate mtn push command for the current directory.  The
command will automatically use the right database and branch based on
the current directory, and can be run in both the source directory and
the build directory.  Does not update the current directory, and does
not run for dependencies.

=head2 mtnsync

Run the appropriate mtn sync command for the current directory.  The
command will automatically use the right database and branch based on
the current directory, and can be run in both the source directory and
the build directory.  Does not update the current directory, and does
not run for dependencies.

=cut

sub mtnOp {
    my($op) = @_;

    die "??" unless $op =~ /^((pull)|(push)|(sync))$/o;
    my $src = rootSrcDir();
    my %mtn_opts = readMtnOptions($src);
    my $branch = $mtn_opts{branch};
    my $database = $mtn_opts{database};

    die "? no branch" unless defined $branch;
    die "? no database" unless defined $database;

    my $syncbranch = $branch;
    $syncbranch =~ s!^(.*/.*)/.*$!$1!o;
    my $server = mtnServer();
    runCommand("mtn","-d",$database,$op,$server,"$syncbranch*");
    runCommand("mtn","-d",$database,'heads','-b',$branch);
}

=pod

=head2 mtnserve

Run the mtn serve command with the appropriate database based on the
current directory.

=cut

sub mtnServe {
    my $src = rootSrcDir();
    my %mtn_opts = readMtnOptions($src);
    die "? no database" unless defined $mtn_opts{database};

    runCommand("mtn","-d",$mtn_opts{database},'serve','*');
}

##### depPublish

=pod

=head2 publish

The publish command is the core logic for making changes globally
available.  It performs the following steps:

  made_changes = true
  while made_changes {
      made_changes = false
      Build and test (C<deptool build -t>)
      Commit any local changes (C<deptool commit>)
      Pull from the central server (C<deptool pull>)
      if made_changes == false {
          Synchronize with the central server 
          # if we got changes here, print a warning before continuing
      }
  }

=cut

sub depPublish {
    print "deppublish: committing any outstanding changes\n";
    depCommit();
    my %options = ( 'made_changes' => 1 );
    while ($options{made_changes}) {
        $options{made_changes} = 0;
        print "deppublish: verifying current version passes regression tests\n";
        depBuild('tests' => 1);
        print "deppublish: pulling in any remote changes\n";
        depWalk(sub { depPullOne(\%options); });

        unless ($options{made_changes}) {
            print "\n" x 5;
            print <<"END";
*** Running the sync.  In the unlikely case that you get any updates, you ***
*** need to get them tested and synchronized quickly because they made it ***
*** out so other people can see them. ***
END
            depWalk(sub { depSyncOne(\%options); });
            print "****** WARNING, got changes; re-running deppublish...\n"
                if $options{made_changes};
        }
    }

##    if (defined $ENV{TESTHOST}) {
##	my $src = rootSrcDir();
##	my $project = basename($src);
##	die "MAILADDR is not defined, and is needed with TESTHOST"
##	    unless defined $ENV{MAILADDR};
##	my $user = $ENV{MAILADDR};
##	print "ssh -t $ENV{TESTHOST} testbuild $project $user background\n";
##	system("ssh -t $ENV{TESTHOST} testbuild $project $user background");
##	croak "Unable to ssh $ENV{TESTHOST} testbuild ($?)"
##	    unless $? == 0;
##    }
}

sub depSyncOne {
    my($options) = @_;

    mtnOp("sync");
    depPullUpdate($options);
}

##### Code review diff

=pod

=head2 code-review I<revision>...

The code-review command is designed to help performing code reviews of
a set of related changes.  For a single revision, it is exactly
equivalent to running kdiff3 on all files that were changed in
I<revision>.  

If multiple revisions are specified, the first step is to build a
single diff between the parent of the earliest revision specified and
the latest revision specified.  Therefore, the code review code will
first sort the revisions by the date they were committed.  Then it
will checkout the parent of the first revision.  Then for each
revision I<r> in date order, it will apply the patch between I<r> and
I<r>'s parent, which may not be the previous listed revision.
Assuming each of the patch commands succeeds, the resulting directory
will be the equivalent of just applying the updates specified by the
revisions in order.  

If one of the patches does not succeed, the code review will prompt
the user to make a repair patch, in particular by creating the file
that should have been created.  The code review tool with then store
the additional patch in /tmp so that it can be re-applied if
necessary.

Regardless, eventually a pair of directories will be created, the
first being the parent of the earliest revision, and the last being
the result of applying all of the patches for each revision and any
recovery patches.  The code review tool then will proceed to review
each of the files that have changed.  It will sort the files such that
cmake files go before others, tests come next, and then headers and
c++ files in alphabetical order.  The user can override this default
order by creating the file /tmp/diff-order-I<last-revision>.txt,
usually by starting with the one specified.

The tool will then prompt for a command.  Commands include:

=over

=item auto

automatically move onto the next step until we get to the end, or the
diff ordering file changes.

=item files

print a list of all the files that are going to be compared

=item exit 

stop the code review; do not clean up temporary files.

=item finish

stop the code review; clean up all temporary files.

=item help

get help usage

=item I<filename-substring>

select the unique filename that matches I<filename-substring> to be
reviewed next, or if multiple files match, then print out an error
message.

=back

Usually users will just hit return to bring up the kdiff3 window for
comparing the two files until they get to the end.  They can
alternately use the auto command to skip having to hit return.

B<Note-bug:> renames currently confuse the code review tool.

=cut

sub codeReview {
    my @revisions = @ARGV;

    my $root_src_dir = rootSrcDir();
    aliasChdir($root_src_dir);
    die "No revisions specified." if @revisions == 0;

    eval 'use File::Copy::Recursive "rcopy";';
    die "aptitude install libfile-copy-recursive-perl?\n$@" if $@;
    my %parents;
    my %dates;
    foreach my $revision (@revisions) {
        my @output = getCmdOutput("mtn log -r $revision --last=1");

        my %info = simpleParse(\@output, 
                               [ qr/^-+$/o => undef,
                                 qr/^Revision: (\S+)$/o => 'revision',
                                 qr/^Ancestor: (\S+)$/o => 'ancestor',
                                 qr/^Author:/o => undef,
                                 qr/^Date: (\S+)$/o => 'date' ]);
        
        $parents{$info{revision}} = $info{ancestor};
        $dates{$info{revision}} = $info{date};
    }

    @revisions = sort { $dates{$a} cmp $dates{$b} } keys %parents;

    my $basedir = "/tmp/code-review-" . getpwuid($UID);
    my $original_dir = $parents{$revisions[0]};
    my $final_dir = $revisions[@revisions - 1];
    if (-d $basedir && -d "$basedir/$original_dir" &&
        -d "$basedir/$final_dir" && -f "$basedir/diff-order") {
        print "$basedir already exists, as do the relevant
first and last revisions and the diff-order file.  
Assuming you just want to continue editing.\n";
    } elsif (-d $basedir) {
        print "Missing expected files to continue diffing in $basedir\n";
        print "Return to delete, ctrl-c to abort: ";
        $_ = <STDIN>;
        runCommand("rm -rf $basedir");
    }

    if (! -d $basedir) {
        mkdir($basedir, 0755) or die "unable to mkdir $basedir: $!";
        codeReviewSequence(\@revisions, \%parents, $basedir);
    } else {
        kdiffDirs($basedir, $original_dir, $final_dir, \@revisions);
    }
}

sub codeReviewSequence {
    my ($revs, $parents, $basedir) = @_;

    my @revisions = @$revs;
    my %mtn_options = readMtnOptions();
    my $database = $mtn_options{database};
    die "missing db in .../_MTN/options" 
        unless defined $database;
    
    my $start = $parents->{$revisions[0]};

    print "Trying to build single sequence diff from ", 
      substr($start,0,20), " to ", substr($revisions[@revisions-1],0,20), 
      "\n  using ", join(", ", map { substr($_, 0, 8) } @revisions), "\n";

    codeReviewCheckout($database, "$basedir/$start", $start);
    
    my $last = $start;
    while (@revisions > 0) {
        my $to = $revisions[0];
        my $from = $parents->{$to};

        print "Trying to patch $last\n   with ", substr($from, 0, 20), 
            " -> ", substr($to, 0, 20), "\n";

        codeReviewPatch($database, $basedir, $last, $from, $to);
        $last = $to;
        shift @revisions;
    }

    print "Successfully built single sequence for review.\n";

    makeDiffOrder($basedir, $start, $last);
    kdiffDirs($basedir, $start, $last, $revs);
}

# TODO-sprint: make .thrift files show up early by default.
sub makeDiffOrder {
    my ($basedir, $original_dir, $final_dir) = @_;

    my $reference_file = "/tmp/diff-order-$final_dir.txt";
    if (-f $reference_file) {
        print "$reference_file exits; just using it.\n";
        copy($reference_file, "$basedir/diff-order")
            or die "copy failed: $!";
        return;
    }
    my @changed = getChanged($basedir, $original_dir, $final_dir);

    my %file_key;
    map { die "?? $_" unless m!^(.+/)?([^/]+?)(?:\.(\w+))?$!o;
          my ($dir, $name, $suffix) = ($1, $2, $3);
	  $suffix ||= 'no-suffix';
          my $test_key = $dir =~ m!/tests\b!o ? 0 : 1;
          my $header_key = $suffix eq 'hpp' ? 0 : 1;
          my $cmake_key = $name =~ /^CMake/o ? 0 : 1;
          
          # sort cmake files first, then tests, then by filename 
          # sorting headers before sources.
          
          $file_key{$_} = "$cmake_key-$test_key-$name-$header_key";
      } @changed;
    @changed = sort { $file_key{$a} cmp $file_key{$b} } @changed;
    
    my $fh = new FileHandle ">$basedir/diff-order"
        or die "bad";
    print $fh join("\n", @changed), "\n";
    close($fh);

    print "store this file as $reference_file to automatically use it.";
    print "Changed:\n", join("\n", @changed), "\n";
}

sub kdiffDirs {
    my ($basedir, $original_dir, $final_dir, $revisions) = @_;

    # TODO-sprint: make this extract the relevant part from each log
    # message for the file we are reviewing.

    foreach my $rev (@$revisions) {
        quietRunCommand("mtn log -r $rev --last=1");
    }
    my $cur = '*start*';
    my $auto = undef;
    while(1) {
        print "\n";
        print "------------------------------------------------------------\n";
        print "Last file diffed: $cur\n";
        my $next = getNextDiffFile($basedir, $cur);
        print "Current next file to diff: $next\n";
        print "Editable diff ordering file: $basedir/diff-order\n";
        my $default = "diff $next";
        $default = "finish" if $next eq '*end*';
        print "commands: auto, files, exit, finish, help\n";
        print "Enter filename substring or command [$default]: ";
        if (defined $auto && (-M "$basedir/diff-order") == $auto) {
            print "[auto]\n";
            $_ = '';
        } else {
            $_ = <STDIN>;
            chomp;
        }
        $_ = 'finish' if $_ eq '' && $default eq 'finish';
        if ($_ eq '') {
            my $check_next = getNextDiffFile($basedir, $cur);
            if ($check_next ne $next) {
                print "\n***ordering file changed***\n";
                redo;
            }
            my $original = "$basedir/$original_dir/$next";
            my $final = "$basedir/$final_dir/$next";
            unless (-f $original) {
                print "Assuming $final is new file, creating empty temporary\n";
                my $fh = new FileHandle ">$original"
                    or die "bad: $!";
                close($fh);
            }
            if (! (-f $original && -f $final)) {
                warn "$original or $final missing; looping";
                $auto = undef;
                redo;
            }
            eval {
                runCommand('kdiff3','--L1', "original ($next)", '--L2', "new ($next)", 
                           "$basedir/$original_dir/$next", 
                           "$basedir/$final_dir/$next");
            };
            # warn "kdiff3 command failed (ignoring)" if $@;
            $cur = $next;
        } elsif ($_ eq 'auto') {
            $auto = -M "$basedir/diff-order";
        } elsif ($_ eq 'files') {
            my @files = getDiffOrder($basedir);
            print "\n\nFiles:\n", join("\n", @files), "\n";
        } elsif ($_ eq 'exit') {
            last;
        } elsif ($_ eq 'finish') {
            runCommand("rm -rf $basedir");
            last;
        } elsif ($_ eq 'help') {
            print <<"END_OF_HELP";

auto: skip the prompt for a command until the next file to diff changes
files: list the files we will diff.
exit: exit from deptool code-review-diff
finish: delete the code review temporary directories and exit
help: show this help
*: try to find a file with this as a substring and diff it next.
END_OF_HELP
        } else { 
            $cur = selectPrevDiffFile($basedir, $_, $cur);
        }
    }
}

sub getChanged {
    my ($basedir, $start, $last) = @_;

    my @old_files = findFilesPrefix("$basedir/$start");
    my @new_files = findFilesPrefix("$basedir/$last");
    die "??" if @new_files == 0;
    my @changed;
    my %old;
    map { $old{$_} = 1 } @old_files;
    map { 
        if (defined $old{$_}) {
            ++$old{$_};
            my $old = "$basedir/$start/$_";
            my $new = "$basedir/$last/$_";
            if (-d $old && -d $new) {
                # ignore
            } else {
                die "? $_" if -d $old || -d $new;
                push(@changed, $_) unless compare($old, $new) == 0;
            }
        } else {
            push(@changed, $_)
                unless -d "$basedir/$last/$_" || /\.orig$/o || /\.rej$/o;
        }
      } @new_files;

    while(my($k,$v) = each %old) {
        die "old file $k missing" unless $v == 2;
    }

    @changed = grep(!/((-final-version)|(-pre-fix))$/o, @changed);
    return @changed;
}

sub getNextDiffFile {
    my($basedir, $cur) = @_;

    my @order = getDiffOrder($basedir);
    return $order[0] if $cur eq '*start*';
    for(my $i=0; $i < @order; ++$i) {
        if ($order[$i] eq $cur) {
            return '*end*' if $i + 1 == @order;
            return $order[$i+1];
        }
    }
    return "**ERROR: Unable to find file $cur";
}

sub selectPrevDiffFile {
    my ($basedir, $target, $cur) = @_;

    my @order = getDiffOrder($basedir);
    my @match = grep(/$target/, @order);
    if (@match == 0) {
        print "\n\n************\nNo match for $target found. Choices:\n", 
            join("\n", @order), "\n";
        return $cur;
    } elsif (@match > 1) {
        print "\n\n************\nMultiple matches for $target found:\n",
            join("\n", @match), "\n";
        return $cur;
    } else {
        for(my $i=0; $i < @order; ++$i) {
            if ($order[$i] eq $match[0]) {
                return "*start*" if $i == 0;
                return $order[$i-1];
            }
        }
        die "??";
    }
}

sub getDiffOrder {
    my($basedir) = @_;

    my $fh = new FileHandle "$basedir/diff-order"
        or die "Can't open $basedir/diff-order for read: $!";
    my @order = <$fh>;
    close($fh);
    grep(chomp, @order);

    return @order;
}

sub getCmdOutput {
    my($cmd) = @_;

    my $fh = new FileHandle "$cmd 2>/dev/null |" 
        or die "Unable to run $cmd: $!";
    my @ret = <$fh>;
    close($fh) or die "close failed: $!\ncommand is $cmd";
    die "$cmd failed" unless $? == 0;
    return @ret;
}

sub simpleParse {
    my($data, $matches) = @_;

    my %ret;

    # print join(", ", @$matches);
    die "bad parse" unless @$data >= @$matches;
    for(my $i=0; $i < @$matches/2; ++$i) {
        local $_ = $data->[$i];
        chomp;
        my $match = $matches->[2*$i];
        my $var = $matches->[2*$i+1];

        die "?? $i" unless defined $match;
        die "Error on line $i expected $match, got '$_'"
            unless /$match/;
        $ret{$var} = $1 if defined $var;
    }
    return %ret;
}

sub codeReviewCheckout {
    my($database, $targetdir, $revision) = @_;

    quietRunCommand('mtn', 'checkout', '-d', $database, 
                    '-r', $revision, $targetdir);
}

sub codeReviewPatch {
    my ($database, $basedir, $last, $from, $to) = @_;

    rcopy("$basedir/$last", "$basedir/$to")
        or die "copy ($basedir/$last,$basedir/$to) failed: $!";
    quietRunCommand("mtn diff -d $database -r $from -r $to >$basedir/$to.patch");
    eval {
        quietRunCommand("patch -U -p0 --ignore-whitespace -d $basedir/$to <$basedir/$to.patch >$basedir/$to.patch.err 2>&1");
    };
    if ($@) {
        my @failed = grep(/\.rej$/o, findFilesPrefix("$basedir/$to"));
        print "\n\n**************\n";
        print "Patch failed for files: ", join(", ", @failed), "\n";

        foreach my $file (@failed) {
            my $patch = $file;
            $file =~ s/\.rej$//o;
            my $repairpatch = $file;
            $repairpatch =~ s!/!_!go;
            $repairpatch = "/tmp/repair-$to-$repairpatch";
            if (-f $repairpatch) {
                print "$repairpatch exists; will just apply\n";
                runCommand("patch -p4 -d $basedir/$to < $repairpatch");
            } else {
                print "will start $ENV{EDITOR} for $file and rejected patch\n";
                print "return to continue, ctrl-c to abort: ";
                $_ = <STDIN>;
                copy("$basedir/$to/$file","$basedir/$to/$file-pre-fix");
                runCommand("mtn cat -r $to $file >$basedir/$to/$file-final-version");
                runCommand("$ENV{EDITOR} $basedir/$to/$file $basedir/$to/$patch $basedir/$to/$file-final-version");
                if (compare("$basedir/$to/$file-pre-fix","$basedir/$to/$file") == 0) {
                    print "No changes made.  Return to save empty patch, ctrl-c to abort: ";
                    $_ = <STDIN>;
                }

                print "Saving repair difference as $repairpatch\n";
                eval { runCommand("diff -u $basedir/$to/$file-pre-fix $basedir/$to/$file >$repairpatch"); };
            }
            unlink("$basedir/$to/$file-pre-fix", "$basedir/$to/$patch",
                   "$basedir/$to/$file-final-version");
        }
    }
}

sub findFilesPrefix {
    my ($prefix) = @_;

    my @ret;
    find(sub { local $_ = $File::Find::name;
               die "??" unless s,^$prefix\b/?,,;
               push(@ret, $_); }, $prefix);
    return @ret;
}

##### Change Directory functions 
# Actually just prints out what has to happen such that eval of returned string
# in bourne shells will change the directory.

=pod

=head2 cdsrc I<cwd>

The source and build directories maintain parallel structure.
Therefore if you are currently in $BUILD_OPT/Lintel/src/tests, it can
be useful to jump to $PROJECTS/Lintel/src/tests.  The cdsrc command
will print out the shell command necessary to make this switch.
Therefore you probably want an alias along the lines of:

    s () { eval `$DEPTOOL cdsrc $PWD` }

to make it easier to type the command in.  The s command will deal
correctly with sub-build-type directories except it will get confused
if you have a source directory named project-something.


=head2 cdopt I<cwd> [I<build-type>]

The cdopt command performs the reverse jump from cdsrc, it moves from
a position under $PROJECTS to one under $BUILD_OPT.  The build-type
optional argument allows you to have multiple directories that all
build from the source directory with different build options.  Since
deptool wants to remember the build type for each directory, it
actually prints out a command that sets the environment variable for
the build-type if needed.  An alias along the lines of:

    b () { eval `$DEPTOOL cdopt $PWD "$@"` }

will make it easier to issue this command.  Unfortunately because of
the environment setting, this command only works with bourne-shells
right now.  If you specify '' as the build type, it will remove the
build type from whatever directory you are currently in.

=head2 cddebug

The cddebug command is the same as cdopt, except it takes you to the
debug directory.  The natural alias is therefore: 

    d () { eval `$DEPTOOL cddebug $PWD "$@"` }

=cut

sub cdSrc {
    my $cwd = cdInitialPrep(1, 'cdsrc <cur-working-dir>');
    
    my ($project, $subprojdir, $buildtype) = divideDir($cwd);
    $subprojdir ||= '';
    my $srcdir = "$ENV{PROJECTS}/$project$subprojdir";
    if (-d $srcdir) {
        print "cd $srcdir\n";
        exit(0);
    } else {
        print "echo '$srcdir does not exist'\n";
        exit(1);
    }
}

sub cdBuild {
    my($what) = @_;

    my $cwd = cdInitialPrep(2, "cd${what} <cur-working-dir> [build-type]");

    my ($project, $subprojdir, $buildtype) = divideDir($cwd);
    $subprojdir ||= '';
    $buildtype ||= '';

    my $cleanproj = $project;
    $cleanproj =~ s/\W/_/go;

    my $deptool_env = "deptool_${cleanproj}_subbuild";
    $buildtype = $ENV{$deptool_env}
        if $buildtype eq '' && defined $ENV{$deptool_env};
    $buildtype = $ARGV[1] if @ARGV == 2;

    my $xbuildtype = $buildtype eq '' ? '' : "-$buildtype";
    my $envvar = $what eq 'opt' ? 'BUILD_OPT' : 'BUILD_DEBUG'; 
    my $builddir = "$ENV{$envvar}/$project$xbuildtype$subprojdir";
    if (! -d $builddir) {
        print STDERR "$builddir missing, creating...\n";
        mkpath($builddir) or die "Unable to mkdir $builddir: $!";
    }

    print "export ${deptool_env}=$buildtype;\n";
    print "cd $builddir\n";
}

sub cdInitialPrep {
    my ($maxargs, $usage) = @_;
    $maxargs ||= 1;
    unless (defined $ENV{PROJECTS} && defined $ENV{BUILD_DEBUG} &&
            defined $ENV{BUILD_OPT}) {
        print "echo 'can not use deptool cd operations environment is not set up'\n";
        exit(1);
    }

    unless (@ARGV >= 1 && @ARGV <= $maxargs && -d $ARGV[0]) {
        print "echo 'Usage: deptool $usage'";
        exit(1);
    }
    return $ARGV[0];
}

# TODO: combine this somehow with srcDir
# returns (project, subdir, build-type)
sub divideDir {
    my($dir) = @_;
    
    my $projects = projects();
    my $opt = buildOpt();
    my $debug = buildDebug();
    if ($dir =~ m!^$projects/([^/]+)(/.+)?$!o) {
	return ($1, $2, undef);
    } elsif ($dir =~ m!^$opt/([^/]+?)(?:-(\w+))?(/.+)?$!o) {
	return ($1, $3, $2);
    } elsif ($dir =~ m!^$debug/([^/]+?)(?:-(\w+))?(/.+)?$!o) {
	return ($1, $3, $2);
    } else {
	print "echo '$dir is not under $projects, $opt, or $debug'\n";
	exit(1);
    }
}

##### Common -- depwalk

sub depWalkRecurse ($$$$$);

sub depWalk {
    my($fn, $use_build_type) = @_;

    my $src = rootSrcDir();
    depWalkRecurse($fn, $src, {}, $use_build_type, '');
}

sub depWalkRecurse ($$$$$) {
    my($fn, $src, $visited, $use_build_type, $build_type) = @_;
    if ($use_build_type) {
        return if $visited->{"$src $build_type"};
        $visited->{"$src $build_type"} = 1;
    } else {
        return if $visited->{$src};
        $visited->{$src} = 1;
    }

    aliasChdir($src);
    my @vcdeps = readVCDeps(".version_control_deps");
    if (@vcdeps > 0) {
        my $projects = projects();
        foreach my $dep (@vcdeps) {
            my $sub_build_type = '';
            $dep =~ s!^[^/]*/!!;
            if ($dep =~ /^(.+);(\w+)$/o) {
                ($dep,$sub_build_type) = ($1,$2);
            }

            my $depsrc = "$projects/$dep";
            die "Unable to find dependency $dep as $projects/$dep"
                unless -d $depsrc;
            depWalkRecurse($fn, $depsrc, $visited, $use_build_type, 
                           $sub_build_type);
        }
    }
    aliasChdir($src);
    print "depwalk: running walk function in $src ($build_type)\n\n"
        unless $quiet;
    &$fn($build_type);
    print "\n";
}

# TODO: combine this somehow with divideDir
sub srcDir {
    my $start = aliasGetCwd();
    my $projects = projects();
    my $debug = buildDebug();
    my $opt = buildOpt();

    local $_ = $start;
    my $build_subdir;
    if (m!^$projects/!o) { 
        # in a source directory already
    } elsif (-d "_MTN") {
        # in some kind of source directory already.
    } elsif (m!^(($debug)|($opt))/!o) {
        s!^(($debug)|($opt))/!!o;
        if (-d "$projects/$_") {
            $_ = "$projects/$_";
        } elsif (m!^(\w[^/]+)-(\w+)(/.*)$!o && -d "$projects/$1/$3") {
            $build_subdir = $2;
            $_ = "$projects/$1$3";
        } elsif (m!^(\w[^/]+)-(\w+)$!o && -d "$projects/$1") {
            $build_subdir = $2;
            $_ = "$projects/$1";
        } else {
            die "$start is under a build directory, but can't find related source dir";
        }
    } else {
        die "$_ is not under a projects or build directory";
    }
    return ($_, $build_subdir) if wantarray;
    return $_;
}

sub rootSrcDir {
    my $start = srcDir();
    local $_ = $start;
    while (! -d "$_/_MTN") {
        s!/[^/]+$!!o;
        die "Unable to find _MTN directory anywhere under $start"
            if $_ eq '';
    }
    return $_;
}

##### Env functions

=pod

=head2 getenv I<what>

The getenv command allows you to get the environment variables that
are needed for deptool to work without prompting.  This command has
two forms, one that gets a specific environment variable and prints it
out, and one that prints out a string that can be evaluated to set all
the environment variables in the shell.  Therefore what can have a
number of values:

=over

=item for-sh

Print out all of the environment variables formatted for sh-style
shells.  This command does not prompt for input, so if values are not
currently set in the environment, the defaults will be used.

=item for-csh

The same as for-sh, except for csh-based shells.

=item projects

The PROJECTS environment variable.  Specifies the root directory for
sources of projects.

=item buildRoot

The BUILD_ROOT environment variable.  Specifies the parent directory
for the optimize and debug build directories.  Unused if BUILD_OPT and
BUILD_DEBUG are set.

=item operatingSystem

The OS environment variable.  Automatically inferred by looking at
various files in /etc to determine the operating system type and
version.

=item unameM

The UNAME_M environment variable.  The result of running uname -m as
you have to build differently for different architecture types.

=item buildDebug

The BUILD_DEBUG environment variable.  Specifies the root directory
for debugging builds.  Defaults to $BUILD_ROOT/dbg-$OS-$UNAME_M, or
$BUILD_ROOT/debug if the latter exists.

=item buildOpt

The BUILD_OPT environment variable.  Specifies the root directory
for optimized builds.  Defaults to $BUILD_ROOT/opt-$OS-$UNAME_M, or
$BUILD_ROOT/optimize if the latter exists.

=item makeParallelism

The MAKE_PARALLELISM environment variable.  Defaults to ceil(1.5 *
ncores), or 1 if the number of cores can't be determined.  Useful for
C<make -j $MAKE_PARALLELISM>.

=item mtnServer

The MTN_SERVER environment variable.  Defaults to usi.hpl.hp.com.
Needed to determine the central repository for public updates.

=back

=cut

sub getEnv {
    my $result = GetOptions("y!" => \$auto_yes_to_prompts,
                            "quiet!" => \$quiet);
                            
    usage("Unknown error") unless $result;
    usage("Missing requested env var") unless @ARGV == 1;

    my $env = $ARGV[0];
    if ($env =~ /^for-((sh)|(csh))$/o) {
        my $shell = $1;
        $quiet = 1;
        $auto_yes_to_prompts = 1;
        
        printEnv($shell, 'PROJECTS', \&projects);
        printEnv($shell, 'BUILD_ROOT', \&buildRoot);
        printEnv($shell, 'OS', \&operatingSystem);
        printEnv($shell, 'UNAME_M', \&unameM);
        printEnv($shell, 'BUILD_DEBUG', \&buildDebug);
        printEnv($shell, 'BUILD_OPT', \&buildOpt);
        printEnv($shell, 'MAKE_PARALLELISM', \&makeParallelism);
        printEnv($shell, 'MTN_SERVER', \&mtnServer);
    } else {
        usage("Bad env var request") unless $env =~ /^\w+$/o;
        my $ret = eval "$ARGV[0]()";
        die "Unknown env var $env"
            if $@ && $@ =~ /^Undefined subroutine/o;
        die $@ if $@;
        
        print "$ret\n";
    }
}

sub printEnv {
    my($shell, $envvar, $fn) = @_;

    my $val = &$fn();
    if ($shell eq 'sh') {
        print qq{export $envvar="$val";\n};
    } elsif ($shell eq 'csh') {
        print qq{setenv $envvar "$val";\n};
    } else {
        die "?? $shell";
    }
}

sub projects {
    $Cache::projects ||= $ENV{PROJECTS};
    unless(defined $Cache::projects) {
        userPrompt("missing \$ENV{PROJECTS}; assume $ENV{HOME}/projects");
        $Cache::projects = "$ENV{HOME}/projects";
    }
    return $Cache::projects;
}

sub buildRoot {
    $Cache::build_root ||= $ENV{BUILD_ROOT};
    unless(defined $Cache::build_root) {
        userPrompt("missing \$ENV{BUILD_ROOT}; assume $ENV{HOME}/build");
        $Cache::build_root = "$ENV{HOME}/build";
    }
    return $Cache::build_root;
}

sub operatingSystem {
    $Cache::operating_system ||= $ENV{OS};
    unless(defined $Cache::operating_system) {
        if (-f "/etc/debian_version") {
            my $debver = new FileHandle("/etc/debian_version") 
                or die "Can't open /etc/debian_version for read: $!";
            $_ = <$debver>;
            close($debver);
            chomp;
            if (/^\d+\.\d+$/o) {
                $Cache::operating_system = "debian-$_";
            } elsif (m!^([a-z]+)/sid$!o) {
                $Cache::operating_system = "debian-$1-unstable";
            } elsif (m!^testing$!o) {
                $Cache::operating_system = "debian-testing-unstable";
            } else {
                s/\W//go;
                $Cache::operating_system = "debian-unknown-$_";
            }
        } elsif (-f "/etc/redhat-release") {
            my $rhver = new FileHandle("/etc/redhat-release")
                or die "Can't open /etc/redhat-release for read: $!";
            $_ = <$rhver>;
            close($rhver);
            chomp;
            if (/^Red Hat Enterprise Linux.+release (\d+)\b/o) {
                $Cache::operating_system = "rhel$1";
            } else {
                s/\W//go;
                $Cache::operating_system = "rh-unknown-$_";
            }
        } else {
            $Cache::operating_system = "unknown";
        }
        if ($Cache::operating_system =~ /unknown/o) {
            warn "Unknown OS, using $Cache::operating_system";
        }
    }
    return $Cache::operating_system;
}

sub unameM {
    $Cache::uname_m ||= $ENV{UNAME_M};

    unless(defined $Cache::uname_m) {
        $Cache::uname_m = `uname -m`;
        chomp $Cache::uname_m;
        if ($Cache::uname_m eq '') {
            $Cache::uname_m = "arch_unknown";
            warn "Unknown architecture, using arch_unknown";
        }
    }
    return $Cache::uname_m;
}

sub buildDebug {
    $Cache::build_debug ||= $ENV{BUILD_DEBUG};
    unless(defined $Cache::build_debug) {
        my $root = buildRoot();
        if (-d "$root/debug") {
            $Cache::build_debug = "$root/debug";
        } else {
            $Cache::build_debug 
                = buildRoot() . "/dbg-" . operatingSystem() . "-" . unameM();
        }
        userPrompt("missing \$ENV{BUILD_DEBUG}; assume $Cache::build_debug");
    }
    return $Cache::build_debug;
}

sub buildOpt {
    $Cache::build_optimize ||= $ENV{BUILD_OPT};
    unless(defined $Cache::build_optimize) {
        my $root = buildRoot();
        if (-d "$root/optimize") {
            $Cache::build_optimize = "$root/optimize";
        } else {
            $Cache::build_optimize 
                = buildRoot() . "/opt-" . operatingSystem() . "-" . unameM();
        }
        userPrompt("missing \$ENV{BUILD_OPT}; assume $Cache::build_optimize");
    }
    return $Cache::build_optimize;
}

sub makeParallelism {
    my $fh = new FileHandle("/proc/cpuinfo");
    my $nprocessors = 0;
    if ($fh) {
        while(<$fh>) {
            ++$nprocessors if /^processor\s+:\s+\d+$/o;
        }
        close($fh);
    }
    if ($nprocessors == 0) {
        print "Warning: unable to find \# processors in /proc/cpuinfo\n"
            unless $quiet;
        return 1;
    }
    return POSIX::ceil($nprocessors * 1.5); # oversubscribe by 50%
}

sub mtnServer {
    $Cache::mtn_server ||= $ENV{MTN_SERVER};
    unless(defined $Cache::mtn_server) {
        userPrompt("assume default mtn server usi.hpl.hp.com (set via \$MTN_SERVER)");
        $Cache::mtn_server = "usi.hpl.hp.com";
    }
    return $Cache::mtn_server;
}

##### Common functions

sub readConfigFile {
    my $cfile = "$ENV{HOME}/.deptoolrc";
    if (! $noconfig && -f $cfile && -r $cfile) {
	my $config = new FileHandle($cfile)
	    or die "Can't open $cfile for read: $!";
	while (<CONFIG>) {
	    chomp;
	    if (/^([A-Z_]+)=(.+)$/o) {
		$ENV{$1} = $2;
	    } elsif (/^([A-Z_]+)=$/o) {
		delete $ENV{$1};
	    } else {
		warn "Ignoring invalid line '$_' in $cfile";
	    }
	}
	close($config);
    }
}

sub readVCDeps {
    my ($filename) = @_;

    return () unless -r $filename;

    my $vcdeps = new FileHandle("$filename")
        or die "Can't read $filename: $!";
    my @ret;
    while(<$vcdeps>) {
        chomp;
        s/^\s+//o; s/\s+$//o;
        next unless /\w/o;
        push(@ret, split(/\s+/o));
    }
    close($vcdeps);
    return @ret;
}

sub userPrompt {
    my($msg) = @_;

    return if $auto_yes_to_prompts && $quiet;

    print STDERR "\nDo you want to: $msg\n";
    print STDERR "Return to continue, ctrl-c to abort: ";
    if ($auto_yes_to_prompts) {
        print STDERR "[auto-yes]\n";
    } else {
        $_ = <STDIN>;
        die "You provided 'n' for input, aborting anyway"
            if /^n/io;
    }
}

sub runCommand {
    my(@command) = @_;

    print "Running: ", join(" ", @command), "\n";
    quietRunCommand(@command);
}

sub quietRunCommand {
    my(@command) = @_;

    my $ret = system(@command);

    confess "'" . join(" ", @command) . "' failed ($ret)" unless $ret == 0;
}

sub aliasChdir {
    my($dir) = @_;

    chdir($dir) or die "Unable to chdir($dir): $!";
    my $here = getcwd();
    return if defined $Cache::alias_cd{$here};
    print "ACD $here -> $dir\n" if 0;
    $Cache::alias_cd{$here} = $dir;
}

sub aliasGetCwd {
    my $here = getcwd();
    print "AG $here -> $Cache::alias_cd{$here}\n" if 0;
    return $Cache::alias_cd{$here} 
        if defined $Cache::alias_cd{$here};
    return $here;
}

sub readMtnOptions {
    my ($src) = @_;

    $src = rootSrcDir() unless defined $src;
    my $fh = new FileHandle("$src/_MTN/options")
        or die "Can't open $src/_MTN/options for read: $!";
    my %ret;
    while(<$fh>) {
        $ret{branch} = $1 if /^\s*branch \"(.+)\"$/o;
        $ret{database} = $1 if /^\s*database \"(.+)\"$/o;
    }
    close($fh);

    return %ret;
}

=pod

=head1 BUGS

=over

=item *

cdopt/cddbg only work for sh-style shells.

=item *

code-review gets confused by file renames

=item *

pull should walk the current directory before dependent ones to deal
with new dependencies.

=back

=head1 AUTHOR

Eric Anderson <anderse@hpl.hp.com>
