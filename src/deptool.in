#!@PERL_BINARY@ -w
# -*- Perl -*-
#
#  (c) Copyright 2004-2008, Hewlett-Packard Development Company, LP
#
#  See the file named COPYING for license details
#
# Script for checking out and 
use strict;

use Carp;
use Cwd;
use Digest::SHA1 'sha1_hex';
use English;
use File::Compare;
use File::Copy;
use File::Path;
use File::Find;
use File::stat;
use FileHandle;
use Getopt::Long;
use POSIX 'ceil';

# TODO: pull should walk in the current directory before walking in the
# dependent ones since it may need additional dependencies, and/or they
# may have changed.  Test case is revision in tla that switched the
# dependencies around.

# TODO: builds have to be serialized, but tests should be runnable in parallel.

sub usage {
    print "Usage: $0 <command> [-y (yes to prompts)] [args]\n";
    print "  init [--server=<hostname>] [branch-prefix...]\n";
    print "  checkout <branch-substring...>\n";
    print "  pull\n";
    print "  build [-t (and test)] [-d (debug build)] [-b (optimize build)]\n";
    print "  commit\n";
    print "  publish\n";
    confess @_ if @_ > 0;
    exit(0);
}

my $auto_yes_to_prompts = 0;
my $quiet = 0;

Getopt::Long::Configure(qw/pass_through no_auto_abbrev/);
GetOptions("y!" => \$auto_yes_to_prompts,
	   "quiet!" => \$quiet, 
           "projects=s" => \$Cache::projects,
	   "root|build-root=s" => \$Cache::build_root,
	   "operating-system=s" => \$Cache::operating_system,
	   "uname-m=s" => \$Cache::uname_m,
	   "build-debug=s" => \$Cache::build_debug,
	   "build-opt=s" => \$Cache::build_optimize);
Getopt::Long::Configure(qw/no_pass_through auto_abbrev/);

usage("Missing argument") if @ARGV == 0;

my %commands = ('checkout' => \&depCheckout,
		'pull' => \&depPull,
		'build' => \&depBuild,
		'commit' => \&depCommit,
		'publish' => \&depPublish,
		# below commands don't run in all dep dirs.
		'init' => \&depInit,
		'cmake' => \&runCMake,
		'pin' => \&setPin,
		'code-review' => \&codeReview,
		'mtnpull' => sub { mtnOp("pull"); },
		'mtnpush' => sub { mtnOp("push"); },
		'mtnsync' => sub { mtnOp("sync"); },
		'mtnserve' => \&mtnServe, 
		'getenv' => \&getEnv);

my $command = shift @ARGV;
my $monotone_dir = "$ENV{HOME}/.monotone";
my $fn = $commands{$command};

usage("Unrecognized command '$command'") unless defined $fn;
$|=1;

# handle case where start dir is a symlink
aliasChdir($ENV{PWD}) if defined $ENV{PWD};
&$fn;

##### Dependency Init

sub depInit {
    checkForMtn();

    my $server = "usi.hpl.hp.com";
    my $email;
    my $result = GetOptions("server=s" => \$server);
    usage("Unknown error") unless $result;
    my @branch_prefixes = @ARGV;
    if (@branch_prefixes == 0) {
	print "Assuming default branch prefix ssd\n";
	@branch_prefixes = ("ssd");
    }

    initMtnDir();
    initMtnKeysRc();

    initDbs($server, \@branch_prefixes);
}

sub checkForMtn {
    my @paths = split(/:/, $ENV{PATH});
    foreach my $path (@paths) {
	return if -x "$path/mtn";
    }
    die "Unable to find mtn binary in path; you should repair this.
Usually yum install monotone or apt-get install monotone will work.
http://usi.hpl.hp.com/twiki/pub/USI/MonotoneVersionControl/mtn-static
is a static linux binary, alternately, you can get something from
the monotone web site: http://www.monotone.ca/";
}

sub initMtnDir {
    if (! -d $monotone_dir) {
	userPrompt("Create monotone directory $monotone_dir");
	mkdir($monotone_dir, 0755) or die "Unable to mkdir $monotone_dir: $!";
    }
}

sub initMtnKeysRc {
    if (! -d "$monotone_dir/keys") {
	print <<EOF;

The key will be generated with an empty password.  You can change it
by running mtn chkeypass or mtn passphrase depending on your monotone
version.

WARNING: if you already have a monotone key, you should ctrl-c now, and copy
WARNING: your key file over.  Monotone deals poorly with multiple keys with
WARNING: the same e-mail address.
EOF
	
	print "Enter e-mail address for identifying monotone key: ";
	my $email = <STDIN>;
	chomp $email;
	die "?? $email" unless $email =~ /^\S+\@\w+\.\w+$/o;

	runCommand("yes default-password | mtn genkey $email");

	print <<"END";
Key generated with password 'default-password'; can be changed with
mtn chkeypass or mtn passphrase depending on your monotone version
END

	chmod(0700, "$monotone_dir/keys");
	if (-f "$monotone_dir/monotonerc") {
	    print <<"EOF";
You probably want to add:
function get_passphrase(keypair_id)
  return "default-password"
end
To your $monotone_dir/monotonerc file
EOF
        } else {
	    userPrompt("Create default monotonerc?");
	    my $mtnrc = new FileHandle(">$monotone_dir/monotonerc")
		or die "can't write $monotone_dir/monotonerc: $!";
	    print $mtnrc <<"EOF";
-- Change with mtn chkeypass or mtn passphrase, then change here.
function get_passphrase(keypair_id)
  return "default-password"
end

-- Next three are for letting you run your own server 
function get_netsync_read_permitted (collection, identity)
  return true
end

function get_netsync_write_permitted (identity)
  if (identity == "$email") then return true end
  return false
end

function get_netsync_anonymous_read_permitted (collection)
  return true
end

-- performance optimization
function get_vcache_size()
  return 512*1024*1024
end
EOF
            chmod(0700, "$monotone_dir/monotonerc");
        }
    }
}

sub initDbs {
    my($server, $branch_prefixes) = @_;

    foreach my $branch_prefix (@$branch_prefixes) {
	my $db = $branch_prefix;
	$db =~ s/\W.*$//o;
	die "Invalid branch prefix $branch_prefix, should start with normal chars"
	    if $db eq '';
	unless (-f "$monotone_dir/${db}.db") {
	    userPrompt("create local repository $monotone_dir/${db}.db");
	    runCommand("mtn -d $monotone_dir/${db}.db db init");
	}

	userPrompt("pull $branch_prefix* from $server (can take a while)");
	my $qm = quotemeta $branch_prefix;
	runCommand("mtn -d $monotone_dir/${db}.db pull $server $qm\\*");
    }
}

##### Dependency Checkout

sub depCheckout {
    my $result = GetOptions("y!" => \$auto_yes_to_prompts);
    usage("Unknown error") unless $result;

    usage("No branch-substrings specified") unless @ARGV > 0;

    my $projects = projects();
    
    my @dbs = glob("$monotone_dir/*.db");
    die "No *.db files in $monotone_dir; did you run $0 init?"
	unless @dbs > 0;

    my @branches;
    my %branch_to_db;
    foreach my $db (@dbs) {
	my $tmp = new FileHandle("mtn -d $db list branches |");
	my @tmp = <$tmp>;
	close($tmp);
	grep(chomp, @tmp);
	push(@branches, @tmp);
	map { 
	    warn "duplicate db ($db, $branch_to_db{$_}) for branch $_
will use latter."
		if defined $branch_to_db{$_};
	    $branch_to_db{$_} = $db 
	    } @tmp;
    }

    my @branch_regexes = (@ARGV);
    my %did_regex;
    while (@branch_regexes > 0) {
	my $branch_regex = shift @branch_regexes;
	next if $did_regex{$branch_regex};
	$did_regex{$branch_regex} = 1;

	my @possibles = grep(/$branch_regex/, @branches);
	die "No branches found matching $branch_regex"
	    unless @possibles > 0;
	@possibles = sort { length $a <=> length $b } @possibles;
	
	my $branch = shift @possibles;
	foreach $_ (@possibles) {
	    die "?? $branch $_" unless /^$branch/;
	}
	
	my $db = $branch_to_db{$branch};
	my $dir = $branch;
	$dir =~ s!^\w+(\.\w+)*/!!o; # strip uniqueifier we put on
	my $path = "$projects/$dir";
	print << "END";

Selected branch $branch
From database $db
Inferred projects directory $dir
Inferred full path $path
END

	if (-d "$path/_MTN") {
	    print "Found $path/_MTN; skipping redundant checkout.\n";
	} else {
	    userPrompt("continue even though you have a / in the directory")
		if $dir =~ m!/!o;
	    userPrompt("continue even though path already exists")
		if -d $path;
	
	    runCommand("mtn -d $db co -b $branch $path");
	}
	my @vcdeps = readVCDeps("$path/.version_control_deps");
	if (@vcdeps > 0) {
	    print "Adding VC dependencies: ", join(" ", @vcdeps), "\n";
	    push(@branch_regexes, @vcdeps);
	}
    }	
}

##### Dependency build

sub depBuild {
    my %options = @_;
    $options{tests} ||= 0;

    my $cwd = aliasGetCwd();
    my $debug = buildDebug();
    if ($cwd =~ /^$debug/o) {
	$options{mode} = 'debug';
    } else {
	$options{mode} = 'optimize';
    }

    my $ret = GetOptions("y!" => \$auto_yes_to_prompts,
			 "quiet!" => \$quiet,
			 "t|tests!" => \$options{tests},
			 "o|optimize" => sub { $options{mode} = 'optimize' },
			 "d|debug" => sub { $options{mode} = 'debug' });
    usage("unknown option to build") unless $ret;

    $options{builddir} = $options{mode} eq 'debug' ? buildDebug() : buildOpt();
    $options{projects} = projects();

    depWalk(sub { depBuildOne(\%options) });
}

sub depBuildOne {
    my ($options) = @_;

    my $src = aliasGetCwd();
    die "? '$src' '$options->{projects}'" 
	unless $src =~ /^$options->{projects}/o;
    my $build = $src;
    $build =~ s!$options->{projects}/!$options->{builddir}/!o;
    print "Building in $build\n" unless $quiet;
    unless(-d $build) {
	mkpath($build);
    }
    aliasChdir($build);
    depBuildCheckOld($src, $build, $options);
    depBuildMake($src, $build, $options);
    depBuildTest($build, $options);
    depBuildInstall($build, $options)
}

sub depBuildCheckOld {
    my($src, $build, $options) = @_;

    print "depbuild: Checking if any files in $src\n";
    print "depbuild: are out of date w.r.t $build\n";
    if (! -f ".deptool.build_stamp") {
	print "depbuild:  missing .deptool.build_stamp, build definitely out of date\n";
	return;
    }
    if ($options->{did_install}) {
	print "depbuild:  did an install in another directory, so we are out of date\n";
	unlink(".deptool.build_stamp") or die "?";
	return;
    }
    my @old_files = depBuildFindOld($src);
    if (@old_files > 0) {
	print "\n" x 5;
	print join("\n", @old_files, '');
	print "depbuild: out of date w.r.t above files.";
	unlink(".deptool.build_stamp") or die "?";
	return;
    }
    print "depbuild:  up to date in $build\n";
}

sub depBuildFindOld {
    my ($src) = @_; 
    die "??" unless defined $src;

    my $ref_stat = stat(".deptool.build_stamp")
	or die "Unable to stat .deptool.build_stamp: $!";
    my @newer;
    find(sub { return unless -f $_;
	       return if $File::Find::name =~ m!^$src/_MTN!;
	       my $stat = stat($_) or die "can't stat $_: $!";
	       push(@newer, $File::Find::name)
		   if $stat->mtime() > $ref_stat->mtime(); }, $src);
	       
    return @newer;
}

sub depBuildMake {
    my($src, $build, $options) = @_;

    if (-f ".deptool.build_stamp") {
	print "depbuild: $build already has current build\n";
	return;
    }
    if (! -f "Makefile" || ! -d "CMakeFiles" || ! -f "CMakeCache.txt") {
	local @ARGV = ();
	print "depbuild: creating makefile in $build\n";
	runCMakeConfig();
    }

    print "depbuild: building...\n";
    my $make_parallelism = makeParallelism();
    runCommand("make", "-j", $make_parallelism);
    stamp("build");
}

sub depBuildTest {
    my($build, $options) = @_;
    return unless $options->{tests};

    if (stampUpToDate("test")) {
	print "depbuild: Tests are up to date in $build\n";
    } else {
	print "depbuild: Running tests in $build...\n";
	runCommand("make","test");
	stamp("test");
    } 
}

sub stampUpToDate {
    my($which) = @_;

    return 0 unless -f ".deptool.${which}_stamp";
    my $build_stat = stat(".deptool.build_stamp")
	or die "Unable to stat .deptool.build_stamp: $!";
    my $which_stat = stat(".deptool.${which}_stamp")
	or die "Unable to stat .deptool.${which}_stamp: $!";
    return $which_stat->mtime() > $build_stat->mtime();
}

sub stamp {
    my($which) = @_;
    
    my $filename = ".deptool.${which}_stamp";
    while(1) {
	my $fh = new FileHandle("+>>$filename")
	    or die "Can't open $filename for append: $!";
	close($fh);
	utime undef, undef, $filename;
	last if $which eq 'build' || stampUpToDate($which);
	print "deptool: sleep(1) to make sure ${which} timestamp is more recent than build\n";
	sleep(1);
    }
}

sub depBuildInstall {
    my($build, $options) = @_;

    if (stampUpToDate("install","build")) {
	print "depbuild: Install up to date in $build\n";
    } else {
	runCommand("make","install");
	stamp("install");
	$options->{did_install} = 1;
    }
}

##### Set pin

### setPin -- pin the revision that we will pull to; deals with people 
### accidentally messing up dependencies while still letting you commit

sub setPin {
    die "Have unknown files; setpin is disallowed"
	if depCommitHaveUnknown();
    die "Have changes; setpin is disallowed"
	if depCommitHaveChanges();
    my @heads = getCurHeads();
    die "Have multiple heads; setpin is disallowed"
	unless @heads == 1;
    my($revision) = @ARGV;

    if (defined $revision) {
	runCommand("mtn","update","-r",$revision);
    }

    $revision = getCurRevision()
	unless defined $revision;
    
    my $filename = depPinFilename();
    my $fh = new FileHandle ">>$filename"
	or die "Unable to open $filename for append: $!";
    print $fh "$heads[0] $revision\n";
    print "Pinning to $revision so long as head remains at $heads[0]\n";
    close($fh);
}

##### Dependency pull

### deppull -- pull all of the dependency tree sources
sub depPull {
    my %options;
    depWalk(sub { depPullOne(\%options); });
}

### sets $options->{made_changes} if we made changes.

sub depPullOne {
    my($options) = @_;

    depCommitOne();
    mtnOp("pull");
    depPullMerge();
    depPullUpdate($options);
}

sub depPullMerge {
    while(1) {
	my $fh = new FileHandle "mtn automate heads |";
	my @heads = getCurHeads();
	last if @heads == 1;
	my $cwd = aliasGetCwd();
	print "\n" x 5, "You have multiple heads in $cwd.";
	userPrompt("merge the heads");
	runCommand("mtn","merge");
    }
}

sub depPullUpdate {
    my($options) = @_;

    my $cwd = aliasGetCwd();
    my $cur_rev = getCurRevision();
    if (-f depPinFilename()) {
	my @heads = getCurHeads();
	die "??" unless @heads == 1;
	
	if (foundPin($cur_rev, $heads[0])) {
	    print "deppull: You are currently pinned to revision $cur_rev\n";
	    return;
	} else {
	    print <<"END";


You would be pinned to $cur_rev, but the head
has been updatd.  To reset the pin:
cd $cwd; deptool pin $cur_rev
END
            # skip prompting, will do so for the update.
	}
    }
    while(1) {
	my $cur_rev = getCurRevision();
	my @heads = getCurHeads();
	die "??" unless @heads == 1;
	last if $cur_rev eq $heads[0];
	print <<"END";
You current checkout is not up to date in $cwd.
$cur_rev != $heads[0]
END
        userPrompt("update to the current revision");
	runCommand("mtn","update");
	$options->{made_changes} = 1;
    }
}

sub foundPin {
    my($rev, $head) = @_;

    my $filename = depPinFilename();
    return 0 unless -r $filename;
    my $fh = new FileHandle($filename)
	or die "Can't open $filename for read: $!";
    while(<$fh>) {
	return 1 if /^$head $rev$/;
    }
    return 0;
}

sub getCurHeads {
    my($fh) = new FileHandle("mtn automate heads |")
	or die "Unable to fork: $!";
    my @heads = <$fh>;
    close($fh);
    die "??" unless @heads > 0;
    grep(chomp, @heads);
    return @heads;
}

sub getCurRevision {
    my($fh) = new FileHandle("mtn automate get_base_revision_id |")
	or die "Unable to fork: $!";

    local $_ = <$fh>;
    die "??" unless $_ =~ /^[a-fA-F0-9]{40}$/o;
    chomp;
    close($fh);
    return $_;
}

sub depPinFilename {
    return "$ENV{HOME}/.monotone/deptool-version-pins";
}

##### Dependency commit

### depcommit -- commit all the files in the dependency tree;
### generates the variable depcommit_made_changes as a side effect

sub depCommit {
    my %options;

    depWalk(\&depCommitOne);
}

sub depCommitOne {
    my $cwd = aliasGetCwd();

    die "depcommit: ERROR missing _MTN directory in $cwd"
	unless -d "_MTN";
    depCommitUnknown();
    depCommitDoCommit();
}

sub ignoresFileName() {
    return "$ENV{HOME}/.monotone/deptool-commit-ignores";
}

sub depCommitUnknown { 
    my $cwd = aliasGetCwd();
    return unless depCommitHaveUnknown();
    my @unknown = depCommitGetUnknown();
    while(1) {
	print "You have un-added files in $cwd:\n";
	print @unknown;
	print "\nDo you want to ignore or add them [no-default]?";
	$_ = <STDIN>; 
	chomp;
	if ($_ eq 'ignore') {
	    my $sha1 = sha1_hex(join('',@unknown));
	    my $ignores_name = ignoresFileName();
	    my $fh = new FileHandle ">>$ignores_name"
		or die "Can't open $ignores_name: $!";
	    print $fh "$cwd $sha1\n";
	    close($fh);
	    return;
	} elsif ($_ eq 'add') {
	    print "Adding files...\n";
	    runCommand("mtn","add","--unknown");
	    return;
	} else {
	    print "Expected 'ignore' or 'add', not '$_'; try again\n";
	}
    }
}

sub depCommitHaveUnknown {
    my @unknown = depCommitGetUnknown();

    return 0 if @unknown == 0;
    my $fh = new FileHandle ignoresFileName();
    if ($fh) {
	my $cwd = aliasGetCwd();
	my $sha1 = sha1_hex(join('', @unknown));
	while(<$fh>) {
	    return 0 if $_ eq "$cwd $sha1\n";
	}
    }

    return 1;
}

sub depCommitGetUnknown {
    my $fh = new FileHandle "mtn list unknown |"
	or die "bad fork mtn: $!";
    my @unknown = <$fh>;
    close($fh);
    die "?? mtn" if $?;
    
    return @unknown;
}

sub depCommitHaveChanges {
    my $fh = new FileHandle "mtn diff |"
	or die "fork fail: $!";
    $_ = <$fh>;
    return 1 unless /^\#\s*$/o;
    $_ = <$fh>;
    return 1 unless /^\# no changes\s*$/o;
    $_ = <$fh>;
    return 1 unless /^\#\s*$/o;
    $_ = <$fh>;
    return 1 if defined $_;
    return 0;
}
    
sub depCommitDoCommit {
    my $cwd = aliasGetCwd();
    my $first_time = 1;
    while(1) {
	if (!depCommitHaveChanges()) {
	    print "depcommit: no changes in $cwd\n"
		if $first_time;
	    return;
	}
	$auto_yes_to_prompts = 0 unless $first_time;
	$first_time = 0;
	print "depcommit: you have uncommitted differences in $cwd
depcommit: will show differences after successful test\n";
	userPrompt("build and test");
	depBuild('tests' => 1);
	print "\n" x 20;
	aliasChdir($cwd);
	runCommand("mtn","diff");
	print "\ndepcommit: You have uncommitted differences (shown above) in $cwd\n";
	userPrompt("commit changes");
	eval { runCommand("mtn","commit"); };
	if ($@) {
	    die "$@" if $@ !~ /mtn commit.*failed/o;
	    warn "$@"; # redundant?
	}
    }
}

##### runCMake

sub runCMakeClean {
    my $cwd = aliasGetCwd();
    my $projects = projects();
    my $debug = buildDebug();
    my $opt = buildOpt();

    die "Will not clean unless under projects, debug or optimize dir"
	unless $cwd =~ m!^(($projects)|($debug)|($opt))/!o;
    print "Cleaning cmake files out of $cwd\n"
	unless $quiet;
    my @files; 
    my @dirs;
    find(sub { push(@files, $File::Find::name) if /^CMakeCache.txt$/o
		   || /^Makefile$/o;
	       push(@dirs, $File::Find::name) if /^CMakeFiles$/o; },
	 $cwd);
    unlink(@files) == scalar @files
	or die "Unable to unlink one of @files: $!";
    rmtree(\@dirs);
    map { die "unable to delete $_" if -d $_ } @dirs;
    return 0;
}

sub runCMakeConfig {
    my $cwd = aliasGetCwd();
    my ($src, $build_subdir) = srcDir();
    my $debug = buildDebug();
    my $opt = buildOpt();

    die "Unable to find expected _MTN directory in $src"
	unless -d "$src/_MTN";

    my @cmakecmd = ('cmake');
    if ($cwd =~ /^$debug/o) {
	push(@cmakecmd, "-D", "CMAKE_INSTALL_PREFIX=$debug", "-D",
	     "CMAKE_BUILD_TYPE=Debug");
    } elsif ($cwd =~ /^$opt/o) {
	push(@cmakecmd, "-D", "CMAKE_INSTALL_PREFIX=$opt", "-D",
	     "CMAKE_BUILD_TYPE=RelWithDebInfo");
    } else {
	die "Not under optimize or debug directory; aborting";
    }

    if (defined $build_subdir) {
	push(@cmakecmd, "-D", "BUILD_SUBDIR=$build_subdir");
    }
    push(@cmakecmd, @ARGV, $src);
    runCommand(@cmakecmd);
}

sub runCMake {
    my $clean = 0;
    my $result = GetOptions("clean!" => \$clean);
    usage("Unknown argument to runCMake") unless $result;

    if ($clean) {
	runCMakeClean();
    } else {
	runCMakeConfig();
    }
}

##### Monotone operations

sub mtnOp {
    my($op) = @_;

    die "??" unless $op =~ /^((pull)|(push)|(sync))$/o;
    my $src = rootSrcDir();
    my %mtn_opts = readMtnOptions($src);
    my $branch = $mtn_opts{branch};
    my $database = $mtn_opts{database};

    die "? no branch" unless defined $branch;
    die "? no database" unless defined $database;

    my $syncbranch = $branch;
    $syncbranch =~ s!^(.*/.*)/.*$!$1!o;
    my $server = mtnServer();
    runCommand("mtn","-d",$database,$op,$server,"$syncbranch*");
    runCommand("mtn","-d",$database,'heads','-b',$branch);
}

sub mtnServe {
    my $src = rootSrcDir();
    my %mtn_opts = readMtnOptions($src);
    die "? no database" unless defined $mtn_opts{database};

    runCommand("mtn","-d",$mtn_opts{database},'serve','*');
}

##### depPublish

### deppublish - command for publishing a set of updates back to a
### central server

sub depPublish {
    print "deppublish: committing any outstanding changes\n";
    depCommit();
    my %options = ( 'made_changes' => 1 );
    while ($options{made_changes}) {
	$options{made_changes} = 0;
	print "deppublish: verifying current version passes regression tests\n";
	depBuild('tests' => 1);
	print "deppublish: pulling in any remote changes\n";
	depWalk(sub { depPullOne(\%options); });

	unless ($options{made_changes}) {
	    print "\n" x 5;
	    print <<"END";
*** Running the sync.  In the unlikely case that you get any updates, you ***
*** need to get them tested and synchronized quickly because they made it ***
*** out so other people can see them. ***
END
            depWalk(sub { depSyncOne(\%options); });
	    print "****** WARNING, got changes; re-running deppublish...\n"
		if $options{made_changes};
	}
    }
}

sub depSyncOne {
    my($options) = @_;

    mtnOp("sync");
    depPullUpdate($options);
}

##### Code review diff

sub codeReview {
    my @revisions = @ARGV;

    die "No revisions specified." if @revisions == 0;

    eval 'use File::Copy::Recursive "rcopy";';
    die "aptitude install libfile-copy-recursive-perl?\n$@" if $@;
    my %parents;
    my %dates;
    foreach my $revision (@revisions) {
	my @output = getCmdOutput("mtn log -r $revision --last=1");

	my %info = simpleParse(\@output, 
			       [ qr/^-+$/o => undef,
				 qr/^Revision: (\S+)$/o => 'revision',
				 qr/^Ancestor: (\S+)$/o => 'ancestor',
				 qr/^Author:/o => undef,
				 qr/^Date: (\S+)$/o => 'date' ]);
	
	$parents{$info{revision}} = $info{ancestor};
	$dates{$info{revision}} = $info{date};
    }

    @revisions = sort { $dates{$a} cmp $dates{$b} } keys %parents;

    my $basedir = "/tmp/code-review-" . getpwuid($UID);
    my $original_dir = $parents{$revisions[0]};
    my $final_dir = $revisions[@revisions - 1];
    if (-d $basedir && -d "$basedir/$original_dir" &&
	-d "$basedir/$final_dir" && -f "$basedir/diff-order") {
	print "$basedir already exists, as do the relevant
first and last revisions and the diff-order file.  
Assuming you just want to continue editing.\n";
    } elsif (-d $basedir) {
	print "Missing expected files to continue diffing in $basedir\n";
	print "Return to delete, ctrl-c to abort: ";
	$_ = <STDIN>;
	runCommand("rm -rf $basedir");
    }

    if (! -d $basedir) {
	mkdir($basedir, 0755) or die "unable to mkdir $basedir: $!";
	codeReviewSequence(\@revisions, \%parents, $basedir);
    } else {
	kdiffDirs($basedir, $original_dir, $final_dir, \@revisions);
    }
}

sub codeReviewSequence {
    my ($revs, $parents, $basedir) = @_;

    my @revisions = @$revs;
    my %mtn_options = readMtnOptions();
    my $database = $mtn_options{database};
    die "missing db in .../_MTN/options" 
	unless defined $database;
    
    my $start = $parents->{$revisions[0]};

    print "Trying to build single sequence diff from ", 
      substr($start,0,20), " to ", substr($revisions[@revisions-1],0,20), 
      "\n  using ", join(", ", map { substr($_, 0, 8) } @revisions), "\n";

    codeReviewCheckout($database, "$basedir/$start", $start);
    
    my $last = $start;
    while (@revisions > 0) {
	my $to = $revisions[0];
	my $from = $parents->{$to};

	print "Trying to patch $last\n   with ", substr($from, 0, 20), 
	    " -> ", substr($to, 0, 20), "\n";

	codeReviewPatch($database, $basedir, $last, $from, $to);
	$last = $to;
	shift @revisions;
    }

    print "Successfully built single sequence for review.\n";

    makeDiffOrder($basedir, $start, $last);
    kdiffDirs($basedir, $start, $last, $revs);
}

# TODO-sprint: make .thrift files show up early by default.
sub makeDiffOrder {
    my ($basedir, $original_dir, $final_dir) = @_;

    my $reference_file = "/tmp/diff-order-$final_dir.txt";
    if (-f $reference_file) {
	print "$reference_file exits; just using it.\n";
	copy($reference_file, "$basedir/diff-order")
	    or die "copy failed: $!";
	return;
    }
    my @changed = getChanged($basedir, $original_dir, $final_dir);

    my %file_key;
    map { die "?? $_" unless m!^(.+/)?([^/]+)\.(\w+)$!o;
	  my ($dir, $name, $suffix) = ($1, $2, $3);
	  my $test_key = $dir =~ m!/tests\b!o ? 0 : 1;
	  my $header_key = $suffix eq 'hpp' ? 0 : 1;
	  my $cmake_key = $name =~ /^CMake/o ? 0 : 1;
	  
          # sort cmake files first, then tests, then by filename 
	  # sorting headers before sources.
	  
	  $file_key{$_} = "$cmake_key-$test_key-$name-$header_key";
      } @changed;
    @changed = sort { $file_key{$a} cmp $file_key{$b} } @changed;
    
    my $fh = new FileHandle ">$basedir/diff-order"
	or die "bad";
    print $fh join("\n", @changed), "\n";
    close($fh);

    print "store this file as $reference_file to automatically use it.";
    print "Changed:\n", join("\n", @changed), "\n";
}

sub kdiffDirs {
    my ($basedir, $original_dir, $final_dir, $revisions) = @_;

    # TODO-sprint: make this extract the relevant part from each log
    # message for the file we are reviewing.

    foreach my $rev (@$revisions) {
	quietRunCommand("mtn log -r $rev --last=1");
    }
    my $cur = '*start*';
    my $auto = undef;
    while(1) {
	print "\n";
	print "------------------------------------------------------------\n";
	print "Last file diffed: $cur\n";
	my $next = getNextDiffFile($basedir, $cur);
	print "Current next file to diff: $next\n";
	print "Editable diff ordering file: $basedir/diff-order\n";
	my $default = "diff $next";
	$default = "finish" if $next eq '*end*';
	print "commands: auto, files, exit, finish, help\n";
	print "Enter filename substring or command [$default]: ";
	if (defined $auto && (-M "$basedir/diff-order") == $auto) {
	    print "[auto]\n";
	    $_ = '';
	} else {
	    $_ = <STDIN>;
	    chomp;
	}
	$_ = 'finish' if $_ eq '' && $default eq 'finish';
	if ($_ eq '') {
	    my $check_next = getNextDiffFile($basedir, $cur);
	    if ($check_next ne $next) {
		print "\n***ordering file changed***\n";
		redo;
	    }
	    my $original = "$basedir/$original_dir/$next";
	    my $final = "$basedir/$final_dir/$next";
	    unless (-f $original) {
		print "Assuming $final is new file, creating empty temporary\n";
		my $fh = new FileHandle ">$original"
		    or die "bad: $!";
		close($fh);
	    }
	    if (! (-f $original && -f $final)) {
		warn "$original or $final missing; looping";
		$auto = undef;
		redo;
	    }
	    eval {
		runCommand('kdiff3','--L1', "original ($next)", '--L2', "new ($next)", 
			   "$basedir/$original_dir/$next", 
			   "$basedir/$final_dir/$next");
	    };
	    # warn "kdiff3 command failed (ignoring)" if $@;
	    $cur = $next;
	} elsif ($_ eq 'auto') {
	    $auto = -M "$basedir/diff-order";
	} elsif ($_ eq 'files') {
	    my @files = getDiffOrder($basedir);
	    print "\n\nFiles:\n", join("\n", @files), "\n";
	} elsif ($_ eq 'exit') {
	    last;
	} elsif ($_ eq 'finish') {
	    runCommand("rm -rf $basedir");
	    last;
	} elsif ($_ eq 'help') {
	    print <<"END_OF_HELP";

auto: skip the prompt for a command until the next file to diff changes
files: list the files we will diff.
exit: exit from deptool code-review-diff
finish: delete the code review temporary directories and exit
help: show this help
*: try to find a file with this as a substring and diff it next.
END_OF_HELP
	} else { 
	    $cur = selectPrevDiffFile($basedir, $_, $cur);
	}
    }
}

sub getChanged {
    my ($basedir, $start, $last) = @_;

    my @old_files = findFilesPrefix("$basedir/$start");
    my @new_files = findFilesPrefix("$basedir/$last");
    die "??" if @new_files == 0;
    my @changed;
    my %old;
    map { $old{$_} = 1 } @old_files;
    map { 
	if (defined $old{$_}) {
	    ++$old{$_};
	    my $old = "$basedir/$start/$_";
	    my $new = "$basedir/$last/$_";
	    if (-d $old && -d $new) {
		# ignore
	    } else {
		die "? $_" if -d $old || -d $new;
		push(@changed, $_) unless compare($old, $new) == 0;
	    }
	} else {
	    push(@changed, $_)
		unless -d "$basedir/$last/$_" || /\.orig$/o || /\.rej$/o;
	}
      } @new_files;

    while(my($k,$v) = each %old) {
	die "old file $k missing" unless $v == 2;
    }

    @changed = grep(!/((-final-version)|(-pre-fix))$/o, @changed);
    return @changed;
}

sub getNextDiffFile {
    my($basedir, $cur) = @_;

    my @order = getDiffOrder($basedir);
    return $order[0] if $cur eq '*start*';
    for(my $i=0; $i < @order; ++$i) {
	if ($order[$i] eq $cur) {
	    return '*end*' if $i + 1 == @order;
	    return $order[$i+1];
	}
    }
    return "**ERROR: Unable to find file $cur";
}

sub selectPrevDiffFile {
    my ($basedir, $target, $cur) = @_;

    my @order = getDiffOrder($basedir);
    my @match = grep(/$target/, @order);
    if (@match == 0) {
	print "\n\n************\nNo match for $target found. Choices:\n", 
	    join("\n", @order), "\n";
	return $cur;
    } elsif (@match > 1) {
	print "\n\n************\nMultiple matches for $target found:\n",
	    join("\n", @match), "\n";
	return $cur;
    } else {
	for(my $i=0; $i < @order; ++$i) {
	    if ($order[$i] eq $match[0]) {
		return "*start" if $i == 0;
		return $order[$i-1];
	    }
	}
	die "??";
    }
}

sub getDiffOrder {
    my($basedir) = @_;

    my $fh = new FileHandle "$basedir/diff-order"
	or die "Can't open $basedir/diff-order for read: $!";
    my @order = <$fh>;
    close($fh);
    grep(chomp, @order);

    return @order;
}

sub getCmdOutput {
    my($cmd) = @_;

    my $fh = new FileHandle "$cmd 2>/dev/null |" 
	or die "Unable to run $cmd: $!";
    my @ret = <$fh>;
    close($fh) or die "close failed: $!";
    die "$cmd failed" unless $? == 0;
    return @ret;
}

sub simpleParse {
    my($data, $matches) = @_;

    my %ret;

    # print join(", ", @$matches);
    die "bad parse" unless @$data >= @$matches;
    for(my $i=0; $i < @$matches/2; ++$i) {
	local $_ = $data->[$i];
	chomp;
	my $match = $matches->[2*$i];
	my $var = $matches->[2*$i+1];

	die "?? $i" unless defined $match;
	die "Error on line $i expected $match, got '$_'"
	    unless /$match/;
	$ret{$var} = $1 if defined $var;
    }
    return %ret;
}

sub codeReviewCheckout {
    my($database, $targetdir, $revision) = @_;

    quietRunCommand('mtn', 'checkout', '-d', $database, 
		    '-r', $revision, $targetdir);
}

sub codeReviewPatch {
    my ($database, $basedir, $last, $from, $to) = @_;

    rcopy("$basedir/$last", "$basedir/$to")
	or die "copy ($basedir/$last,$basedir/$to) failed: $!";
    quietRunCommand("mtn diff -d $database -r $from -r $to >$basedir/$to.patch");
    eval {
	quietRunCommand("patch -U -p0 --ignore-whitespace -d $basedir/$to <$basedir/$to.patch >$basedir/$to.patch.err 2>&1");
    };
    if ($@) {
	my @failed = grep(/\.rej$/o, findFilesPrefix("$basedir/$to"));
	print "\n\n**************\n";
	print "Patch failed for files: ", join(", ", @failed), "\n";

	foreach my $file (@failed) {
	    my $patch = $file;
	    $file =~ s/\.rej$//o;
	    my $repairpatch = $file;
	    $repairpatch =~ s!/!_!go;
	    $repairpatch = "/tmp/repair-$to-$repairpatch";
	    if (-f $repairpatch) {
		print "$repairpatch exists; will just apply\n";
		runCommand("patch -p4 -d $basedir/$to < $repairpatch");
	    } else {
		print "will start $ENV{EDITOR} for $file and rejected patch\n";
		print "return to continue, ctrl-c to abort: ";
		$_ = <STDIN>;
		copy("$basedir/$to/$file","$basedir/$to/$file-pre-fix");
		runCommand("mtn cat -r $to $file >$basedir/$to/$file-final-version");
		runCommand("$ENV{EDITOR} $basedir/$to/$file $basedir/$to/$patch $basedir/$to/$file-final-version");
		if (compare("$basedir/$to/$file-pre-fix","$basedir/$to/$file") == 0) {
		    print "No changes made.  Return to save empty patch, ctrl-c to abort: ";
		    $_ = <STDIN>;
		}

		print "Saving repair difference as $repairpatch\n";
		eval { runCommand("diff -u $basedir/$to/$file-pre-fix $basedir/$to/$file >$repairpatch"); };
		unlink("$basedir/$to/$file-pre-fix", "$basedir/$to/$patch",
		       "$basedir/$to/$file-final-version");
	    }
	}
    }
}

sub findFilesPrefix {
    my ($prefix) = @_;

    my @ret;
    find(sub { local $_ = $File::Find::name;
	       die "??" unless s,^$prefix\b/?,,;
	       push(@ret, $_); }, $prefix);
    return @ret;
}

##### Common -- depwalk

sub depWalk {
    my($fn) = @_;

    my $src = rootSrcDir();
    depWalkRecurse($fn, $src, {});
}

sub depWalkRecurse {
    my($fn, $src, $visited) = @_;
    return if $visited->{$src};
    $visited->{$src} = 1;
    print "depwalk: walking in $src\n"
	unless $quiet;

    aliasChdir($src);
    my @vcdeps = readVCDeps(".version_control_deps");
    if (@vcdeps > 0) {
	my $projects = projects();
	foreach my $dep (@vcdeps) {
	    my $depsrc = "$projects/$dep";
	    die "Unable to find dependency $dep as $projects/$dep"
		unless -d $depsrc;
	    depWalkRecurse($fn, $depsrc, $visited);
	}
    }
    aliasChdir($src);
    &$fn();
}

sub srcDir {
    my $start = aliasGetCwd();
    my $projects = projects();
    my $debug = buildDebug();
    my $opt = buildOpt();

    local $_ = $start;
    my $build_subdir;
    if (m!^$projects/!o) { 
	# in a source directory already
    } elsif (-d "_MTN") {
	# in some kind of source directory already.
    } elsif (m!^(($debug)|($opt))/!o) {
	s!^(($debug)|($opt))/!!o;
	if (-d "$projects/$_") {
	    $_ = "$projects/$_";
	} elsif (m!^(\w[^/]+)-(\w+)(/.*)$!o && -d "$projects/$1/$3") {
	    $build_subdir = $2;
	    $_ = "$projects/$1$3";
	} elsif (m!^(\w[^/]+)-(\w+)$!o && -d "$projects/$1") {
	    $build_subdir = $2;
	    $_ = "$projects/$1";
	} else {
	    die "$start is under a build directory, but can't find related source dir";
	}
    } else {
	die "$_ is not under a projects or build directory";
    }
    return ($_, $build_subdir) if wantarray;
    return $_;
}

sub rootSrcDir {
    my $start = srcDir();
    local $_ = $start;
    while (! -d "$_/_MTN") {
	s!/[^/]+$!!o;
	die "Unable to find _MTN directory anywhere under $start"
	    if $_ eq '';
    }
    return $_;
}

##### Env functions

sub printEnv {
    my($shell, $envvar, $fn) = @_;

    my $val = &$fn();
    if ($shell eq 'sh') {
	print qq{export $envvar="$val";\n};
    } elsif ($shell eq 'csh') {
	print qq{setenv $envvar "$val";\n};
    } else {
	die "?? $shell";
    }
}

sub getEnv {
    my $result = GetOptions("y!" => \$auto_yes_to_prompts,
			    "quiet!" => \$quiet);
			    
    usage("Unknown error") unless $result;
    usage("Missing requested env var") unless @ARGV == 1;

    my $env = $ARGV[0];
    if ($env =~ /^for-((sh)|(csh))$/o) {
	my $shell = $1;
	$quiet = 1;
	$auto_yes_to_prompts = 1;
	
	printEnv($shell, 'PROJECTS', \&projects);
	printEnv($shell, 'BUILD_ROOT', \&buildRoot);
	printEnv($shell, 'OS', \&operatingSystem);
	printEnv($shell, 'UNAME_M', \&unameM);
	printEnv($shell, 'BUILD_DEBUG', \&buildDebug);
	printEnv($shell, 'BUILD_OPT', \&buildOpt);
	printEnv($shell, 'MAKE_PARALLELISM', \&makeParallelism);
	printEnv($shell, 'MTN_SERVER', \&mtnServer);
    } else {
	usage("Bad env var request") unless $env =~ /^\w+$/o;
	my $ret = eval "$ARGV[0]()";
	die "Unknown env var $env"
	    if $@ && $@ =~ /^Undefined subroutine/o;
	die $@ if $@;
	
	print "$ret\n";
    }
}

sub projects {
    $Cache::projects ||= $ENV{PROJECTS};
    unless(defined $Cache::projects) {
	userPrompt("missing \$ENV{PROJECTS}; assume $ENV{HOME}/projects");
	$Cache::projects = "$ENV{HOME}/projects";
    }
    return $Cache::projects;
}

sub buildRoot {
    $Cache::build_root ||= $ENV{BUILD_ROOT};
    unless(defined $Cache::build_root) {
	userPrompt("missing \$ENV{BUILD_ROOT}; assume $ENV{HOME}/build");
	$Cache::build_root = "$ENV{HOME}/build";
    }
    return $Cache::build_root;
}

sub operatingSystem {
    $Cache::operating_system ||= $ENV{OS};
    unless(defined $Cache::operating_system) {
	if (-f "/etc/debian_version") {
	    my $debver = new FileHandle("/etc/debian_version") 
		or die "Can't open /etc/debian_version for read: $!";
	    $_ = <$debver>;
	    close($debver);
	    chomp;
	    if (/^\d+\.\d+$/o) {
		$Cache::operating_system = "debian-$_";
	    } elsif (m!^([a-z]+)/sid$!o) {
		$Cache::operating_system = "debian-$1-unstable";
	    } elsif (m!^testing$!o) {
		$Cache::operating_system = "debian-testing-unstable";
	    } else {
		s/\W//go;
		$Cache::operating_system = "debian-unknown-$_";
	    }
	} elsif (-f "/etc/redhat-release") {
	    my $rhver = new FileHandle("/etc/redhat-release")
		or die "Can't open /etc/redhat-release for read: $!";
	    $_ = <$rhver>;
	    close($rhver);
	    chomp;
	    if (/^Red Hat Enterprise Linux.+release (\d+)\b/o) {
		$Cache::operating_system = "rhel$1";
	    } else {
		s/\W//go;
		$Cache::operating_system = "rh-unknown-$_";
	    }
	} else {
	    $Cache::operating_system = "unknown";
	}
	if ($Cache::operating_system =~ /unknown/o) {
	    warn "Unknown OS, using $Cache::operating_system";
	}
    }
    return $Cache::operating_system;
}

sub unameM {
    $Cache::uname_m ||= $ENV{UNAME_M};

    unless(defined $Cache::uname_m) {
	$Cache::uname_m = `uname -m`;
	chomp $Cache::uname_m;
	if ($Cache::uname_m eq '') {
	    $Cache::uname_m = "arch_unknown";
	    warn "Unknown architecture, using arch_unknown";
	}
    }
    return $Cache::uname_m;
}

sub buildDebug {
    $Cache::build_debug ||= $ENV{BUILD_DEBUG};
    unless(defined $Cache::build_debug) {
	my $root = buildRoot();
	if (-d "$root/debug") {
	    $Cache::build_debug = "$root/debug";
	} else {
	    $Cache::build_debug 
		= buildRoot() . "/dbg-" . operatingSystem() . "-" . unameM();
	}
	userPrompt("missing \$ENV{BUILD_DEBUG}; assume $Cache::build_debug");
    }
    return $Cache::build_debug;
}

sub buildOpt {
    $Cache::build_optimize ||= $ENV{BUILD_OPT};
    unless(defined $Cache::build_optimize) {
	my $root = buildRoot();
	if (-d "$root/optimize") {
	    $Cache::build_optimize = "$root/optimize";
	} else {
	    $Cache::build_optimize 
		= buildRoot() . "/opt-" . operatingSystem() . "-" . unameM();
	}
	userPrompt("missing \$ENV{BUILD_OPT}; assume $Cache::build_optimize");
    }
    return $Cache::build_optimize;
}

sub makeParallelism {
    my $fh = new FileHandle("/proc/cpuinfo");
    my $nprocessors = 0;
    if ($fh) {
	while(<$fh>) {
	    ++$nprocessors if /^processor\s+:\s+\d+$/o;
	}
	close($fh);
    }
    if ($nprocessors == 0) {
	print "Warning: unable to find \# processors in /proc/cpuinfo\n"
	    unless $quiet;
	return 1;
    }
    return POSIX::ceil($nprocessors * 1.5); # oversubscribe by 50%
}

sub mtnServer {
    $Cache::mtn_server ||= $ENV{MTN_SERVER};
    unless(defined $Cache::mtn_server) {
	userPrompt("assume default mtn server usi.hpl.hp.com (set via \$MTN_SERVER)");
	$Cache::mtn_server = "usi.hpl.hp.com";
    }
    return $Cache::mtn_server;
}

##### Common functions

sub readVCDeps {
    my ($filename) = @_;

    return () unless -r $filename;

    my $vcdeps = new FileHandle("$filename")
	or die "Can't read $filename: $!";
    my @ret;
    while(<$vcdeps>) {
	chomp;
	s/^\s+//o; s/\s+$//o;
	next unless /\w/o;
	push(@ret, split(/\s+/o));
    }
    close($vcdeps);
    return @ret;
}

sub userPrompt {
    my($msg) = @_;

    return if $auto_yes_to_prompts && $quiet;

    print STDERR "\nDo you want to: $msg\n";
    print STDERR "Return to continue, ctrl-c to abort: ";
    if ($auto_yes_to_prompts) {
	print STDERR "[auto-yes]\n";
    } else {
	$_ = <STDIN>;
	die "You provided 'n' for input, aborting anyway"
	    if /^n/io;
    }
}

sub runCommand {
    my(@command) = @_;

    print "Running: ", join(" ", @command), "\n";
    quietRunCommand(@command);
}

sub quietRunCommand {
    my(@command) = @_;

    my $ret = system(@command);

    confess "'" . join(" ", @command) . "' failed ($ret)" unless $ret == 0;
}

sub aliasChdir {
    my($dir) = @_;

    chdir($dir) or die "Unable to chdir($dir): $!";
    my $here = getcwd();
    return if defined $Cache::alias_cd{$here};
    print "ACD $here -> $dir\n" if 0;
    $Cache::alias_cd{$here} = $dir;
}

sub aliasGetCwd {
    my $here = getcwd();
    print "AG $here -> $Cache::alias_cd{$here}\n" if 0;
    return $Cache::alias_cd{$here} 
        if defined $Cache::alias_cd{$here};
    return $here;
}

sub readMtnOptions {
    my ($src) = @_;

    $src = rootSrcDir() unless defined $src;
    my $fh = new FileHandle("$src/_MTN/options")
	or die "Can't open $src/_MTN/options for read: $!";
    my %ret;
    while(<$fh>) {
	$ret{branch} = $1 if /^\s*branch \"(.+)\"$/o;
	$ret{database} = $1 if /^\s*database \"(.+)\"$/o;
    }
    close($fh);

    return %ret;
}

